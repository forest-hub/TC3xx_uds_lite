/**
 * \file Ifx_Console.c
 * \brief Main Ifx_Console module implementation file
 *
 * \copyright Copyright (c) 2013 Infineon Technologies AG. All rights reserved.
 *
 * $Date: 2014-03-13 15:49:47 GMT$
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 */

#include <string.h>
#include <stdio.h>
#include <stdarg.h>
#include "FreeRTOS.h"
#include "semphr.h"
//#include "IfxStdIf_DPipe.h"
#include "Ifx_Console.h"
#include <stdarg.h>
#include <string.h>
#include <assert.h>

#include "Ifx_Console.h"
#include "_Utilities/Ifx_Assert.h"
#include "Cpu/Std/IfxCpu_Intrinsics.h"

Ifx_Console Ifx_g_console;

// 打印队列配置（可根据需求调整）
#define PRINT_QUEUE_LENGTH    16          // 队列最大容纳16个打印请求
#define PRINT_BUF_MAX_SIZE    STDIF_DPIPE_MAX_PRINT_SIZE + 1  // 单个打印缓冲区大小（兼容原配置）
#define CONSOLE_TASK_STACK    512         // 串口发送任务栈大小
#define CONSOLE_TASK_PRIORITY 1           // 串口发送任务优先级（低于TCP任务，避免抢占关键逻辑）



// 打印队列句柄（静态全局，仅当前文件可见）
static QueueHandle_t s_print_queue = NULL;


// -------------------------- 串口发送任务（核心） --------------------------
/**
 * 串口发送任务：唯一访问串口硬件的任务，从队列中获取打印请求并执行发送
 * 避免多线程直接操作串口，彻底消除资源竞争
 */
static void console_send_task(void *arg)
{
    (void)arg; // 未使用的参数，消除编译警告
    char recv_buf[PRINT_BUF_MAX_SIZE]; // 接收队列中的打印数据
    Ifx_SizeT send_len;                // 实际发送长度

    while (1)
    {
        // 阻塞等待队列数据（无打印请求时任务休眠，不占用CPU）
        if (xQueueReceive(s_print_queue, recv_buf, portMAX_DELAY) == pdPASS)
        {
            // 仅在串口未禁用发送时执行写入
            if (!Ifx_g_console.standardIo->txDisabled)
            {
                // 计算打印数据长度（不含字符串结束符）
                send_len = (Ifx_SizeT)strlen(recv_buf);

                // 安全检查：避免发送长度超过缓冲区（防止驱动异常）
                if (send_len <= PRINT_BUF_MAX_SIZE - 1)
                {
                    // 调用底层驱动发送数据（TIME_INFINITE确保数据发送完成）
                    (void)IfxStdIf_DPipe_write(
                        Ifx_g_console.standardIo,
                        (void *)recv_buf,
                        &send_len,
                        TIME_INFINITE
                    );
                }
            }
        }
    }
}


// -------------------------- 队列与任务初始化 --------------------------
/**
 * 控制台打印初始化：创建打印队列和串口发送任务
 * 必须在FreeRTOS内核启动后（vTaskStartScheduler()）、首次调用打印前执行
 */
void printInit(void)
{
    // 1. 创建打印队列：每个元素为PRINT_BUF_MAX_SIZE字节的字符串
    s_print_queue = xQueueCreate(PRINT_QUEUE_LENGTH, PRINT_BUF_MAX_SIZE);
    IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, s_print_queue != NULL); // 断言确保队列创建成功

    // 2. 创建串口发送任务：唯一操作串口的任务
    BaseType_t task_create_ret = xTaskCreate(
        console_send_task,          // 任务函数
        "ConsoleSendTask",          // 任务名称（调试用）
        CONSOLE_TASK_STACK,         // 任务栈大小
        NULL,                       // 任务参数（无）
        CONSOLE_TASK_PRIORITY,      // 任务优先级
        NULL                        // 任务句柄（无需外部访问，设为NULL）
    );
    // 断言确保任务创建成功（失败需检查FreeRTOS堆内存配置）
    IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, task_create_ret == pdPASS);
}


// -------------------------- 控制台初始化（原逻辑保留） --------------------------
/**
 * 控制台对象初始化：绑定底层串口DPipe接口
 * @param standardIo：底层串口DPipe驱动接口句柄
 */
void Ifx_Console_init(IfxStdIf_DPipe *standardIo)
{
    IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, standardIo != NULL); // 断言确保驱动接口有效
    Ifx_g_console.standardIo = standardIo;
    Ifx_g_console.align = 0;
    printInit();
}


// -------------------------- 打印函数封装（对外接口） --------------------------
/**
 * 格式化打印函数：将打印请求放入队列，由串口发送任务异步处理
 * @param format：printf兼容的格式化字符串
 * @return：TRUE-打印请求成功入队；FALSE-入队失败（队列满）
 */
# if 0
boolean print(pchar format, ...)
{
    // 安全检查：队列未初始化则直接返回失败
    if (s_print_queue == NULL)
    {
        IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, FALSE); // 触发断言，提示未初始化
        return FALSE;
    }

    char print_buf[PRINT_BUF_MAX_SIZE]; // 临时格式化缓冲区
    va_list args;

    // 1. 格式化打印内容（使用vsnprintf防止缓冲区溢出，原vsprintf存在越界风险）
    va_start(args, format);
    int fmt_ret = vsnprintf(
        print_buf,
        PRINT_BUF_MAX_SIZE - 1,  // 预留1字节给字符串结束符'\0'
        format,
        args
    );
    va_end(args);

    // 2. 格式化结果检查：内容过长时截断（避免内存错乱）
    if (fmt_ret < 0 || fmt_ret >= PRINT_BUF_MAX_SIZE - 1)
    {
        print_buf[PRINT_BUF_MAX_SIZE - 2] = '\0'; // 强制截断并添加结束符
        IFX_ASSERT(IFX_VERBOSE_LEVEL_WARNING, FALSE); // 警告：打印内容被截断
    }

    // 3. 将格式化后的内容放入打印队列（等待100ms，避免队列满时立即失败）
    BaseType_t queue_ret = xQueueSend(
        s_print_queue,
        print_buf,
        pdMS_TO_TICKS(100)  // 队列满时等待100ms，平衡实时性与稳定性
    );

    // 返回入队结果：pdPASS表示成功，否则失败
    return (queue_ret == pdPASS) ? TRUE : FALSE;
}

#else
boolean print(pchar format, ...)
{
    int needs_newline = 1;
    // 安全检查：队列未初始化则直接返回失败
    if (s_print_queue == NULL)
    {
        IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, FALSE);
        return FALSE;
    }

    char print_buf[PRINT_BUF_MAX_SIZE]; // 临时格式化缓冲区
    va_list args;

    // --- 新增：处理换行符 ---
    // 1. 定义一个带换行符的新格式字符串
    char format_with_newline[PRINT_BUF_MAX_SIZE];
    strncpy(format_with_newline, format, PRINT_BUF_MAX_SIZE - 3); // 预留空间给 \r\n 和 \0
    format_with_newline[PRINT_BUF_MAX_SIZE - 3] = '\0'; // 确保字符串结束
    size_t len = strlen(format_with_newline);
    if (len > 0)
       {
           // 情况 B: 末尾是 '\r\n' (Windows 风格)
            if (len > 1 && format_with_newline[len - 1] == '\n' && format_with_newline[len - 2] == '\r')
           {
               needs_newline = 0;
           }
       }

       // 3. 如果需要，就追加 \r\n
       if (needs_newline)
       {
           strncat(format_with_newline, "\r\n", 2);
       }
    // --- 换行符处理结束 ---

    // 1. 使用新的格式字符串进行格式化
    va_start(args, format);
    int fmt_ret = vsnprintf(
        print_buf,
        PRINT_BUF_MAX_SIZE - 1,  // 预留1字节给字符串结束符'\0'
        format_with_newline,     // <--- 使用带换行符的格式字符串
        args
    );
    va_end(args);

    // 2. 格式化结果检查：内容过长时截断
    if (fmt_ret < 0 || fmt_ret >= PRINT_BUF_MAX_SIZE - 1)
    {
        print_buf[PRINT_BUF_MAX_SIZE - 2] = '\0'; // 强制截断并添加结束符
        IFX_ASSERT(IFX_VERBOSE_LEVEL_WARNING, FALSE); // 警告：打印内容被截断
    }

    // 3. 将格式化后的内容放入打印队列
    BaseType_t queue_ret = xQueueSend(
        s_print_queue,
        print_buf,
        pdMS_TO_TICKS(100)
    );

    // 返回入队结果
    return (queue_ret == pdPASS) ? TRUE : FALSE;
}

#endif
