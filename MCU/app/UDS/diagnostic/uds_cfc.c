/**
 *
 * \copyright Copyright (c) 2019 Infineon Technologies AG. All rights reserved.
 *
 *
 *
 *                                 IMPORTANT NOTICE
 *
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such
 * terms of use are agreed, use of this file is subject to following:


 * Boost Software License - Version 1.0 - August 17th, 2003

 * Permission is hereby granted, free of charge, to any person or
 * organization obtaining a copy of the software and accompanying
 * documentation covered by this license (the "Software") to use, reproduce,
 * display, distribute, execute, and transmit the Software, and to prepare
 * derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:

 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.

 *
 */
#include "uds_cfc.h"
#include "can_tp.h"
#include "can_if.h"
#include "uds_server.h"
#include "fl_cfc.h"
#include <UDS_alg_hal.h>

typedef void (*tpfFlashOperateMoreTimecallback)(uint8);
static  tpfFlashOperateMoreTimecallback    gs_pfFlashOperateMoreTimecallback = NULL_PTR;

const static uint8 gs_aEraseMemoryRoutineControlId[]  =  {0x31u, 0x01u, 0xFFu, 0x00u};
const static uint8 gs_aCheckSumRoutineControlId[]     =  {0x31u, 0x01u, 0x02u, 0x02u};
const static uint8 gs_aCheckProgrammingDependencyId[] =  {0x31u, 0x01u, 0xFFu, 0x01u};
const static uint8 gs_aGetVersion[]                   =  {0x31u, 0x01u, 0x03u, 0xFFu};

static void RequestMoreTimeCallback(uint8 i_TxStatus)
{
    if(TX_MSG_SUCCESSFUL == i_TxStatus)
    {
        UDS_RestartS3Server();
    }

    if(NULL_PTR != gs_pfFlashOperateMoreTimecallback)
    {
        (gs_pfFlashOperateMoreTimecallback)(i_TxStatus);
        gs_pfFlashOperateMoreTimecallback = NULL_PTR;
    }
}

/*check routine control right?*/
static uint8 UDS_IsCheckUDS_RoutineControl_0x31Right(const tCheckRoutineCtlInfo i_eCheckRoutineCtlId,
                                        const tUdsAppMsgInfo *m_pstPDUMsg)
{
    uint8 Index = 0u;
    uint8 FindCnt = 0u;
    uint8 *pDestRoutineCltId = NULL_PTR;

    ASSERT(NULL_PTR == m_pstPDUMsg);

    switch(i_eCheckRoutineCtlId)
    {
        case GET_VERSION:
            pDestRoutineCltId = (uint8 *)&gs_aGetVersion[0u];
            FindCnt = sizeof(gs_aGetVersion);

            break;

        default :

            return FALSE;

        /*This is not have break*/
    }

    if((NULL_PTR == pDestRoutineCltId) || (m_pstPDUMsg->xDataLen < FindCnt))
    {

        return FALSE;
    }

    while(Index < FindCnt)
    {
        if(m_pstPDUMsg->aDataBuf[Index] != pDestRoutineCltId[Index])
        {
            return FALSE;
        }

        Index++;
    }

    return TRUE;
}

static void UDS_TXConfrimMsgCallback(uint8 i_status)
{
    if(TX_MSG_SUCCESSFUL == i_status)
    {
        UDS_SetCurrentSession(PROGRAM_SESSION);
        UDS_SetSecurityLevel(NONE_SECURITY);

        /*restart s3server time*/
        UDS_RestartS3Server();
    }
}

/*check routine control right?*/
static uint8 UDS_IsCheckRoutineControlRight(const tCheckRoutineCtlInfo i_eCheckRoutineCtlId,
                                        const tUdsAppMsgInfo *m_pstPDUMsg)
{
    uint8 Index = 0u;
    uint8 FindCnt = 0u;
    uint8 *pDestRoutineCltId = NULL_PTR;

    ASSERT(NULL_PTR == m_pstPDUMsg);

    switch(i_eCheckRoutineCtlId)
    {
    case ERASE_MEMORY_ROUTINE_CONTROL :
        pDestRoutineCltId = (uint8 *)&gs_aEraseMemoryRoutineControlId[0u];

        FindCnt = sizeof(gs_aEraseMemoryRoutineControlId);

        break;

    case CHECK_SUM_ROUTINE_CONTROL :
        pDestRoutineCltId = (uint8 *)&gs_aCheckSumRoutineControlId[0u];

        FindCnt = sizeof(gs_aCheckSumRoutineControlId);

        break;

    case CHECK_DEPENDENCY_ROUTINE_CONTROL :
        pDestRoutineCltId = (uint8 *)&gs_aCheckProgrammingDependencyId[0u];

        FindCnt = sizeof(gs_aCheckProgrammingDependencyId);

        break;

    case GET_VERSION:
        pDestRoutineCltId = (uint8 *)&gs_aGetVersion[0u];
        FindCnt = sizeof(gs_aGetVersion);

        break;

    default :

        return FALSE;

        /*This is not have break*/
    }

    if((NULL_PTR == pDestRoutineCltId) || (m_pstPDUMsg->xDataLen < FindCnt))
    {
        return FALSE;
    }

    while(Index < FindCnt)
    {
        if(m_pstPDUMsg->aDataBuf[Index] != pDestRoutineCltId[Index])
        {
            return FALSE;
        }

        Index++;
    }

    return TRUE;
}

/*do erase flash response*/
static void UDS_DoEraseFlashResponse(uint8 i_Status)
{
    uint8 Index = 0u;
    uint8 aResponseBuf[8u] = {0u};
    uint8 TxDataLen = 0u;
    uint32 UdsTxId = 0u;

    TxDataLen = sizeof(gs_aEraseMemoryRoutineControlId) / sizeof(gs_aEraseMemoryRoutineControlId[0u]);
    aResponseBuf[0u] = gs_aEraseMemoryRoutineControlId[0u] + 0x40u;

    for(Index = 0u; Index < TxDataLen - 1u; Index++)
    {
        aResponseBuf[Index + 1u] = gs_aEraseMemoryRoutineControlId[Index + 1u];
    }

    if(TRUE == i_Status)
    {
        aResponseBuf[TxDataLen] = 0u;
    }
    else
    {
        aResponseBuf[TxDataLen] = 1u;
    }

    TxDataLen++;

    UdsTxId = TP_GetConfigTxMsgID();

    (void)TP_WriteAFrameDataInTP(UdsTxId, NULL_PTR, TxDataLen, aResponseBuf);
}

/*do response checksum*/
static void UDS_DoResponseChecksum(uint8 i_Status)
{
    uint8 Index = 0u;
    uint8 aResponseBuf[8u] = {0u};
    uint8 TxDataLen = 0u;
    uint32 UdsTxId = 0u;

    TxDataLen = sizeof(gs_aCheckSumRoutineControlId) / sizeof(gs_aCheckSumRoutineControlId[0u]);
    aResponseBuf[0u] = gs_aCheckSumRoutineControlId[0u] + 0x40u;

    for(Index = 0u; Index < TxDataLen - 1u; Index++)
    {
        aResponseBuf[Index + 1u] = gs_aCheckSumRoutineControlId[Index + 1u];
    }

    if(TRUE == i_Status)
    {
        aResponseBuf[TxDataLen] = 0u;
    }
    else
    {
        aResponseBuf[TxDataLen] = 1u;

        print("%s: Check CRC faild!\n",__func__);
    }

    TxDataLen++;

    UdsTxId = TP_GetConfigTxMsgID();

    (void)TP_WriteAFrameDataInTP(UdsTxId, NULL_PTR, TxDataLen, aResponseBuf);
}

/*do erase flash*/
 void UDS_DoEraseFlash(uint8 TxStatus)
{
    if(TX_MSG_SUCCESSFUL == TxStatus)
    {
        /*do erase flash need request client delay timeout*/
        Flash_SetOperateFlashActiveJob(FLASH_ERASING, &UDS_DoEraseFlashResponse, 0x31, &UDS_RequestMoreTime);
    }
}



 /*do check sum. If check sum right return TRUE, else return FALSE.*/
 void UDS_DoCheckSum(uint8 TxStatus)
 {
     if(TX_MSG_SUCCESSFUL == TxStatus)
     {
         /*need request client delay time for flash checking flash data*/
         Flash_SetOperateFlashActiveJob(FLASH_CHECKING, &UDS_DoResponseChecksum, 0x31u, &UDS_RequestMoreTime);
     }
 }

 /*Is erase memory routine control?*/
 uint8 UDS_IsEraseMemoryRoutineControl(const tUdsAppMsgInfo *m_pstPDUMsg)
 {
     ASSERT(NULL_PTR == m_pstPDUMsg);

     return UDS_IsCheckRoutineControlRight(ERASE_MEMORY_ROUTINE_CONTROL, m_pstPDUMsg);
 }

 /*Is check sum routine control?*/
 uint8 UDS_IsCheckSumRoutineControl(const tUdsAppMsgInfo *m_pstPDUMsg)
 {
     ASSERT(NULL_PTR == m_pstPDUMsg);

     return UDS_IsCheckRoutineControlRight(CHECK_SUM_ROUTINE_CONTROL, m_pstPDUMsg);
 }

 /*Is check programming dependency?*/
 uint8 UDS_IsCheckProgrammingDependency(const tUdsAppMsgInfo *m_pstPDUMsg)
 {
     ASSERT(NULL_PTR == m_pstPDUMsg);

     return UDS_IsCheckRoutineControlRight(CHECK_DEPENDENCY_ROUTINE_CONTROL, m_pstPDUMsg);
 }
 /*check random is right?*/
 uint8 UDS_IsReceivedKeyRight(const uint8 *i_pReceivedKey,
                                 const uint8 *i_pTxSeed,
                                 const uint8 KeyLen)
 {
     uint8 index = 0u;
     uint8 aPlainText[AES_SEED_LEN] = {0u};

     ASSERT(NULL_PTR == i_pReceivedKey);
     ASSERT(NULL_PTR == i_pTxSeed);

     UDS_ALG_HAL_DecryptData(i_pReceivedKey,(uint32) KeyLen, aPlainText);

     index = 0u;
     while(index < AES_SEED_LEN)
     {
         if(aPlainText[index] != i_pTxSeed[index])
         {
             return FALSE;
         }

         index++;
     }

     return TRUE;
 }

 /*Is get version?*/
 uint8 UDS_IsGetVersion(const tUdsAppMsgInfo *m_pstPDUMsg)
 {
     ASSERT(NULL_PTR == m_pstPDUMsg);

     return UDS_IsCheckUDS_RoutineControl_0x31Right(GET_VERSION, m_pstPDUMsg);
 }


 /*do reset mcu*/
 void UDS_DoResetMCU(uint8 Txstatus)
 {
     if(TX_MSG_SUCCESSFUL == Txstatus)
     {
         /*request enter bootloader mode*/
        // Boot_RequestEnterBootloader();

         /*reset ECU*/
         print("rest ecu\r\n");
        // WATCHDOG_HAL_SystemRest();
      //   while(1)
       //  {
             /*wait watch dog reset mcu*/
       //  }
     }
 }

 /*write message to host basd on UDS for request enter bootloader mode*/
 boolean UDS_TxMsgToHost(void)
 {
     tUdsAppMsgInfo stUdsAppMsg = {0u, 0u, {0u}, NULL_PTR};
     boolean ret = FALSE;

     stUdsAppMsg.xUdsId = TP_GetConfigTxMsgID();
     stUdsAppMsg.xDataLen = 2u;
     stUdsAppMsg.aDataBuf[0u] = 0x51u;
     stUdsAppMsg.aDataBuf[1u] = 0x01u;
     stUdsAppMsg.pfUDSTxMsgServiceCallBack = UDS_TXConfrimMsgCallback;

     ret = TP_WriteAFrameDataInTP(stUdsAppMsg.xUdsId, stUdsAppMsg.pfUDSTxMsgServiceCallBack,
                                  stUdsAppMsg.xDataLen, stUdsAppMsg.aDataBuf);

     return ret;
 }

 void UDS_RequestMoreTime(const uint8 UDSServiceID, void (*pcallback)(uint8))
 {
     tUdsAppMsgInfo stMsgBuf = {0};

     ASSERT(NULL_PTR == pcallback);

     stMsgBuf.xUdsId = TP_GetConfigTxMsgID();
     UDS_SetNegativeErroCode(UDSServiceID, RCRRP, &stMsgBuf);
     stMsgBuf.pfUDSTxMsgServiceCallBack = &RequestMoreTimeCallback;
     gs_pfFlashOperateMoreTimecallback = pcallback;

     (void)TP_WriteAFrameDataInTP(stMsgBuf.xUdsId, stMsgBuf.pfUDSTxMsgServiceCallBack,
                                  stMsgBuf.xDataLen, stMsgBuf.aDataBuf);
 }
