/**
 *
 * \copyright Copyright (c) 2019 Infineon Technologies AG. All rights reserved.
 *
 *
 *
 *                                 IMPORTANT NOTICE
 *
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such
 * terms of use are agreed, use of this file is subject to following:


 * Boost Software License - Version 1.0 - August 17th, 2003

 * Permission is hereby granted, free of charge, to any person or
 * organization obtaining a copy of the software and accompanying
 * documentation covered by this license (the "Software") to use, reproduce,
 * display, distribute, execute, and transmit the Software, and to prepare
 * derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:

 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.

 *
 */

#ifndef __FLS_CFC_H__
#define __FLS_CFC_H__

#include <drv/dflash.h>
#include "string.h"
#include "user_config.h"
#include "uds_cfc.h"


/*reset handler information*/
#define EN_WRITE_RESET_HANDLER_IN_FLASH   (FALSE)  /*enable write reset handler in flash or not*/
#define APP_VECTOR_TABLE_OFFSET           (4096u)  /*vector table offset from gs_astBlockNumA/B*/
#define RESET_HANDLE_OFFSET               (4u)     /*from top vector table to reset handle 508 = 127 * 4*/
#define RESET_HANDLER_ADDR_LEN            (4u)      /*pointer length or reset hanlder length*/


typedef void (*tpfResponse)(uint8);
typedef void (*tpfReuestMoreTime)(uint8, void (*)(uint8));

typedef enum
{
    FLASH_IDLE,                  /*flash idle*/
    FLASH_ERASING,               /*erase flash */
    FLASH_PROGRAMMING,           /*program flash*/
    FLASH_CHECKING,              /*check flash*/
    FLASH_WAITTING               /*waitting transmitted message successful*/
}tFlshJobModle;

typedef enum
{
    BANKA=0,                  /*bank A for app info*/
    BANKB,                    /*bank B for app info*/
    BANK_MAX,                  /*Max num*/
}fl_nvm_bank_num;


typedef enum
{
   // P0BLK_BOOT=0,                /*pflash code for boot */
    P0BLK_CODE_C0=0,               /*pflash code for cpu0 */
    P0BLK_SRC_C0,                  /*pflash code for cpu0 interrupt */
    P0BLK_SPARE0,                  /*pflash spare */

    P1BLK_CODE_C1_2,               /*pflash code for cpu1 cpu2 */
    P1BLK_SRC_C1,                  /*pflash code for cpu1 interrupt */
    P1BLK_SRC_C2,                  /*pflash code for cpu2 interrupt */
    P1BLK_SPARE1,                  /*pflash spare */
    D0BLK_INFO,                    /*dflash bank info  for app*/
    D0BLK_CONFIG,                  /*dflash bank config  for app*/
    D0BLK_SPARE,                   /*dflash spare*/
    PBLK_NUM_MAX,                  /*Max num*/
}fl_pflash_sector_num;

/* needed in the interface between flashloader runtime environment and security module */
typedef struct
{
    uint32 address;              /* block start global address */
    uint32 endaddress;
    uint32 length;               /* block length */
    uint16 maxProgAttempt;       /* maximum program cycle */
} FL_DescriptorType;

typedef struct
{
    uint8 isFingerPrintWritten;                    /* flag if fingerprint has written */
    uint8 isFlashDrvDownloaded;                    /* flag if flash driver has downloaded */
    uint8 errorCode;                               /* error code for flash active job */
    uint8 erasedAPPFlag;                           /*erase app type flag*/
    uint8 requestActiveJobUDSSerID;                /*request active job UDS service ID*/
    uint8 aProgramDataBuff[MAX_FLASH_DATA_LEN];    /*storage program data buff*/
    uint32 startAddr;                              /* current procees start address */
    uint32 length;                                 /* current procees length */
    uint32 receivedDataStartAddr;                  /*recieve data start address*/
    uint32 receivedDataLength;                     /*received data length*/
    uint32 receivedCRC;                            /*received CRC value*/
    uint32 calculateCRCValue;                      /*calculate CRC value*/
    uint32 receiveProgramDataLength;               /*received program data length*/
    tFlDownloadStepType eDownloadStep;             /* flashloader download step */
    tFlshJobModle eActiveJob;                      /* current job status */
    tFlshJobModle eInterruptedJob;                 /*interrupted job*/
    tpfResponse pfActiveJobFinshedCallBack;        /*active job finshed callback*/
    tpfReuestMoreTime pfRequestMoreTime;           /*request more time from host*/
    tAppFlashStatus *pstAppFlashStatus;            /*point app flash status*/
    tFlashOperateAPI stFlashOperateAPI;            /*opeate flash API*/

}tFlsDownloadStateType;
uint8 Flash_WriteFlashAppInfo(void);
tAPPType Flash_GetOldAPPType(void);
boolean FLASH_HAL_GetFlashBankInfo(const tAPPType i_appType, const FL_DescriptorType **o_pAppInfoStartAddr);
boolean FLASH_HAL_GetAPPInfo(const tAPPType i_appType, uint32 *o_pAppInfoStartAddr, uint32 *o_pBlockSize);
tFlshJobModle Flash_GetOperateFlashActiveJob(void);
uint32 FLASH_HAL_GetEraseFlashASectorMaxTimeMs(void);
uint32 FLASH_HAL_GetTotalSectors(const tAPPType i_appType);
tFlDownloadStepType Flash_GetCurDownloadStep(void);
uint8  Flash_ProgramRegion(const uint32 i_addr,const uint8 *i_pDataBuf,const uint32 i_dataLen);
void   Flash_SetNextDownloadStep(const tFlDownloadStepType i_donwloadStep);
uint8  UDS_IsDownloadDataAddrValid(const uint32 i_dataAddr, const uint32 i_dataLen);
void   Flash_SaveDownloadDataInfo(const uint32 i_dataStartAddr, const uint32 i_dataLen);
void   Flash_SetOperateFlashActiveJob(const tFlshJobModle i_activeJob, const tpfResponse i_pfActiveFinshedCallBack,
                                    const uint8 i_requestUDSSerID,const tpfReuestMoreTime i_pfRequestMoreTimeCallback);
#endif
