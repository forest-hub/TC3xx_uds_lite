/**
 *
 * \copyright Copyright (c) 2019 Infineon Technologies AG. All rights reserved.
 *
 *
 *
 *                                 IMPORTANT NOTICE
 *
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such
 * terms of use are agreed, use of this file is subject to following:


 * Boost Software License - Version 1.0 - August 17th, 2003

 * Permission is hereby granted, free of charge, to any person or
 * organization obtaining a copy of the software and accompanying
 * documentation covered by this license (the "Software") to use, reproduce,
 * display, distribute, execute, and transmit the Software, and to prepare
 * derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:

 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.

 *
 */


#include "fl_cfc.h"
#include "fls_app.h"
#include "crc.h"

#define MAX_ERASE_SECTOR_FLASH_MS                (100u)
#define SECTOR_LEN                               (8192u)

tFlsDownloadStateType                            gs_stFlashDownloadInfo;
tAppFlashStatus                                  gs_stAppFlashStatus;

#define Flash_IsFlashEraseSuccessful()           (gs_stAppFlashStatus.isFlashErasedSuccessfull)
#define Flash_IsFlashProgramSuccessful()         (gs_stAppFlashStatus.isFlashProgramSuccessfull)
#define Flash_IsFlashStructValid()               (gs_stAppFlashStatus.isFlashStructValid)
#define Flash_IsFlashAppCrcEqualStorage(xCrc)    ((gs_stAppFlashStatus.crc == xCrc) ? TRUE : FALSE)
#define Flash_CreateAppStatusCrc(o_pCrc)         do{ CRC_HAL_CalculateCRCOnce((uint8 *)&gs_stAppFlashStatus, sizeof(gs_stAppFlashStatus) - 4u, o_pCrc);}while(0u)
#define Flash_SaveAppStatusCrc(xCrc)             do{gs_stAppFlashStatus.crc = xCrc;}while(0u)

/*create app status CRC and save*/
#define Flash_CreateAndSaveAppStatusCrc(o_pCrc)  do{ Flash_CreateAppStatusCrc(o_pCrc); Flash_SaveAppStatusCrc(*o_pCrc);}while(0u)
#define Flash_GetAppStatusPtr() (&gs_stAppFlashStatus)
#define Flash_SaveAppResetHandlerAddr(resetHandlerAddr, resetHnadlerAddrLen) \
do{\
    gs_stAppFlashStatus.appStartAddr = resetHandlerAddr;\
    gs_stAppFlashStatus.appStartAddrLen = resetHnadlerAddrLen;\
}while(0u)
#define Flash_SetEraseFlashStep(eEraseStep)      do{ gs_eEraseFlashStep = (eEraseStep);}while(0u)
//OEM架构应该是三级架构
//使用16KB做一个极小boot用来启动MCU,并使用HSM来仲裁bootload和APP镜像正确，通过bootload升级APP
//这里不考虑信息安全
//PF SC0-SC39 是HSM区域，这部分作boot，不做虑信息安全
const FL_DescriptorType FL_Blk_Did_Info=
{
 //{0xA0000000U, 0xA009FFFFU,0x9FFFFU,   (uint16)0xFFFFU}, /* 640K, HSM_exclusive, for boot */
   0xA02A0000U, 0xA02FFFFFU,0x5FFFFU,   (uint16)0xFFFU  /* 384K,DID*/
};

const FL_DescriptorType FL_Blk_Calib_Info=
{
   0xA0500000U, 0xA05FFFFFU,0xFFFFFU,   (uint16)0xFFFFU /* 1M,calibration */
};

const FL_DescriptorType FL_Blk_Dflash1_Info=
{
   0xAFC00000U, 0xAFC1FFFFU,0x1FFFFU,   (uint16)0xFFFFU /* 128K spare*/
};

//试图使用数据结构去封装出双bank结构体，
//发现需要使用4层结构 基本描述-> flash描述-> bank->
//不如直接两个变量来的直接，可读性
const FL_DescriptorType FL_Blk_A_Info[PBLK_NUM_MAX] =
{
    //pflash 0
    {0xA00A0000U, 0xA018CFFFU,0xECFFFU,   (uint16)0xFFFFU}, /* 948K,cpu0 code */
    {0xA018D000U, 0xA018FFFFU,0x3FFFU,    (uint16)0xFFFFU}, /* 16K,cpu0 interrupter */
    {0xA0190000U, 0xA019FFFFU,0xFFFFU,    (uint16)0xFFFFU}, /* 64K,spare */
    //Pflash1
    {0xA0300000U, 0xA03ECFFFU, 0xECFFFU,  (uint16)0xFFFFU}, /* 948K, cpu1 cpu2 code */
    {0xA03ED000U, 0xA03EEFFFU, 0x1FFFU,   (uint16)0xFFFFU}, /* 8K, cpu1 interrupter */
    {0xA03EF000U, 0xA03EFFFFU, 0x1FFFU,   (uint16)0xFFFFU}, /* 8K, cpu2 interrupter */
    {0xA03F0000U, 0xA03FFFFFU, 0xFFFFU,   (uint16)0xFFFFU}, /* 64K, spare */
    //对应bank Dflash
    {0xAF000000U, 0xAF000FFFU,0xFFFU,     (uint16)0xFFFFU}, /* 4K,info for bank A*/
    {0xAF001000U, 0xAF001FFFU,0xFFFU,     (uint16)0xFFFFU}, /* 4K,info for config*/
    {0xAF002000U, 0xAF01FFFFU,0x1DFFFU,   (uint16)0xFFFFU}, /* 120K,spare*/
};

const FL_DescriptorType FL_Blk_B_Info[PBLK_NUM_MAX] =
{
    //pflash0
    {0xA01A0000U, 0xA028CFFFU, 0xECFFFU, (uint16)0xFFFFU}, /* 948K,cpu0 code */
    {0xA028D000U, 0xA028FFFFU, 0x3FFFU,  (uint16)0xFFFFU}, /* 16K,cpu0 interrupter */
    {0xA0290000U, 0xA029FFFFU, 0xFFFFU,  (uint16)0xFFFFU}, /* 64K,spare */
    //Pflash2
    {0xA0400000U, 0xA04ECFFFU, 0xECFFFU, (uint16)0xFFFFU}, /* 948K,cpu1 cpu2 code */
    {0xA04ED000U, 0xA04EEFFFU, 0x1FFFU,  (uint16)0xFFFFU}, /* 8K,cpu1 interrupter */
    {0xA04EF000U, 0xA04EFFFFU, 0x1FFFU,  (uint16)0xFFFFU}, /* 8K,cpu2 interrupter */
    {0xA04F0000U, 0xA04FFFFFU, 0xFFFFU,  (uint16)0xFFFFU}, /* 64K,spare */
    //对应bank Dflash
    {0xAF020000U, 0xAF020FFFU,0xFFFU,    (uint16)0xFFFFU}, /* 4K,info for bank B*/
    {0xAF021000U, 0xAF021FFFU,0xFFFU,    (uint16)0xFFFFU}, /* 4K,info for config*/
    {0xAF022000U, 0xAF03FFFFU,0x1DFFFU,  (uint16)0xFFFFU}, /* 120K,spare*/
};

/*flash driver config*/
//const BlockInfo_t gs_astFlashDriverBlock[] = {
//  {0x20000000u, 0x20000400u},
//};

/*application can used space*/
//const BlockInfo_t gs_astBlockNumA[] = {
//  {0x00440000u, 0x005D4000},                   /*App A information is in the block.*/
//};

//const uint32 gs_blockNumA = sizeof(gs_astBlockNumA) / sizeof(gs_astBlockNumA[0u]);
static tAPPType Flash_GetNewestAPPType(void);
static boolean  Flash_SaveAppInfoData(const uint32 i_appInfoDataStartAddr);
static tAPPType Flash_DoCheckNewestAPPInfo(const tAppFlashStatus * i_pAppAInfo, const tAppFlashStatus *i_pAppBInfo);
static tAPPType Flash_DoCheckNewestAPPCnt(const tAppFlashStatus * i_pAppAInfo, const tAppFlashStatus *i_pAppBInfo);
/*set operate flash active job.*/
void Flash_SetOperateFlashActiveJob(const tFlshJobModle i_activeJob, const tpfResponse i_pfActiveFinshedCallBack,
                                    const uint8 i_requestUDSSerID,const tpfReuestMoreTime i_pfRequestMoreTimeCallback)
{
    gs_stFlashDownloadInfo.eActiveJob = i_activeJob;
    gs_stFlashDownloadInfo.requestActiveJobUDSSerID = i_requestUDSSerID;
    gs_stFlashDownloadInfo.pfRequestMoreTime = i_pfRequestMoreTimeCallback;
    gs_stFlashDownloadInfo.pfActiveJobFinshedCallBack = i_pfActiveFinshedCallBack;
}

/*get reset handler information*/
void FLASH_HAL_GetRestHanlderInfo(boolean *o_pIsEnableWriteResetHandlerInFlash, uint32 *o_pResetHanderOffset,
                                   uint32* o_pResetHandlerLength)
{
    ASSERT(NULL_PTR == o_pIsEnableWriteResetHandlerInFlash);
    ASSERT(NULL_PTR == o_pResetHanderOffset);
    ASSERT(NULL_PTR == o_pResetHandlerLength);

    *o_pIsEnableWriteResetHandlerInFlash = EN_WRITE_RESET_HANDLER_IN_FLASH;
    *o_pResetHanderOffset = APP_VECTOR_TABLE_OFFSET + RESET_HANDLE_OFFSET;
    *o_pResetHandlerLength = RESET_HANDLER_ADDR_LEN;
}



 boolean FLASH_HAL_GetFlashBankInfo(const tAPPType i_appType, const FL_DescriptorType **o_pAppInfoStartAddr)
 {
     boolean result = FALSE;
     if (o_pAppInfoStartAddr == NULL)
     {
         return FALSE;
     }

     switch (i_appType)
        {
            case APP_A_TYPE:
                 *o_pAppInfoStartAddr = FL_Blk_A_Info;

                result = TRUE;
                break;
            case APP_B_TYPE:
                 *o_pAppInfoStartAddr = FL_Blk_B_Info;

                 result = TRUE;
                break;
            default:

                break;
        }
     return result;
 }

 boolean FLASH_HAL_GetFlashConfigInfo(const tAPPType i_appType, uint32 *o_pAppInfoStartAddr, uint32 *o_pBlockSize)
 {
     boolean result = FALSE;
     switch (i_appType)
        {
            case APP_A_TYPE:
                *o_pAppInfoStartAddr = FL_Blk_A_Info[D0BLK_CONFIG].address;
                *o_pBlockSize = FL_Blk_A_Info[D0BLK_CONFIG].endaddress - FL_Blk_A_Info[D0BLK_CONFIG].address;
                result = TRUE;
                break;
            case APP_B_TYPE:
                 *o_pAppInfoStartAddr = FL_Blk_B_Info[D0BLK_CONFIG].address;
                 *o_pBlockSize = FL_Blk_B_Info[D0BLK_CONFIG].endaddress - FL_Blk_B_Info[D0BLK_CONFIG].address;
                 result = TRUE;
                break;
            default:

                break;
        }
     return result;
 }

 boolean FLASH_HAL_GetAPPInfo(const tAPPType i_appType, uint32 *o_pAppInfoStartAddr, uint32 *o_pBlockSize)
 {
     boolean result = FALSE;
     switch (i_appType)
        {
            case APP_A_TYPE:
                *o_pAppInfoStartAddr = FL_Blk_A_Info[D0BLK_INFO].address;
                *o_pBlockSize = FL_Blk_A_Info[D0BLK_INFO].endaddress - FL_Blk_A_Info[D0BLK_INFO].address;
                result = TRUE;
                break;
            case APP_B_TYPE:
                 *o_pAppInfoStartAddr = FL_Blk_B_Info[D0BLK_INFO].address;
                 *o_pBlockSize = FL_Blk_B_Info[D0BLK_INFO].endaddress - FL_Blk_B_Info[D0BLK_INFO].address;
                 result = TRUE;
                break;
            default:

                break;
        }
     return result;
 }



 /*save flash data buf*/
 static uint8 Flash_SavedFlashData(const uint8 *i_pDataBuf, const uint8 i_dataLen)
 {
     ASSERT(NULL_PTR == i_pDataBuf);

     if(i_dataLen > MAX_FLASH_DATA_LEN)
     {
         return FALSE;
     }

     memcpy(gs_stFlashDownloadInfo.aProgramDataBuff, i_pDataBuf, i_dataLen);

     gs_stFlashDownloadInfo.receiveProgramDataLength = i_dataLen;

     return TRUE;
 }

 /*read application informaiton from flash*/
 static void Flash_ReadNewestAppInfoFromFlash(void)
 {
     tAPPType newestAppType = APP_A_TYPE;
     uint32 appInfoStart = 0u;
     uint32 appInfoBlocksize = 0u;
     boolean result = FALSE;

     newestAppType = Flash_GetNewestAPPType();

     result = FLASH_HAL_GetAPPInfo(newestAppType, &appInfoStart, &appInfoBlocksize);

     if((sizeof(tAppFlashStatus) <= appInfoBlocksize) && (TRUE == result))
     {
         result = Flash_SaveAppInfoData(appInfoStart);
     }
 }

 /*Is application in flash valid? If valid return TRUE, else return FALSE.*/
 uint8 Flash_IsAppInFlashValid(void)
 {
     if(((TRUE == Flash_IsFlashProgramSuccessful()) && (TRUE == Flash_IsFlashEraseSuccessful())) &&
        (TRUE == Flash_IsFlashStructValid()))
     {
         return TRUE;
     }

     return FALSE;
 }

 /*Is read application inforemation from flash valid?*/
 uint8 Flash_IsReadAppInfoFromFlashValid(void)
 {
     uint32 xCrc = 0u;

     /*read application information from flash*/
     Flash_ReadNewestAppInfoFromFlash();

     Flash_CreateAppStatusCrc(&xCrc);

     return Flash_IsFlashAppCrcEqualStorage(xCrc);

 }
 /*do check programming dependency*/
  uint8 UDS_DoCheckProgrammingDependency(void)
 {
     uint8 ret = FALSE;

     if(TRUE == Flash_IsReadAppInfoFromFlashValid())
     {
         if(TRUE == Flash_IsAppInFlashValid())
         {
             ret = TRUE;
         }
         else
         {
             ret = FALSE;
         }
     }
     else
     {
         ret = FALSE;
     }

     return ret;
 }

  /*save app info data*/
  static boolean Flash_SaveAppInfoData(const uint32 i_appInfoDataStartAddr)
  {
      boolean res = FALSE;

      gs_stAppFlashStatus = *(tAppFlashStatus*)i_appInfoDataStartAddr;
      res = TRUE;

      return res;
  }
  /*save download data information, the API called by UDS request download service*/
  void Flash_SaveDownloadDataInfo(const uint32 i_dataStartAddr, const uint32 i_dataLen)
  {
      /*program data info*/
      gs_stFlashDownloadInfo.startAddr = i_dataStartAddr;
      gs_stFlashDownloadInfo.length = i_dataLen;

      /*calculate data CRC info*/
      gs_stFlashDownloadInfo.receivedDataStartAddr = i_dataStartAddr;
      gs_stFlashDownloadInfo.receivedDataLength = i_dataLen;
  }

  /*get current donwload step*/
  tFlDownloadStepType Flash_GetCurDownloadStep(void)
  {
      return gs_stFlashDownloadInfo.eDownloadStep;
  }

  /*save received check sum crc*/
  void Flash_SavedReceivedCheckSumCrc(uint32 i_receivedCrc)
  {
      gs_stFlashDownloadInfo.receivedCRC = (uint32)i_receivedCrc;
  }

  /*set next downlaod step.*/
  void Flash_SetNextDownloadStep(const tFlDownloadStepType i_donwloadStep)
  {
      gs_stFlashDownloadInfo.eDownloadStep = i_donwloadStep;
  }

  /*get flash driver start and length*/
  boolean FLASH_HAL_GetFlashDriverInfo(uint32 *o_pFlashDriverAddrStart, uint32 *o_pFlashDriverEndAddr)
  {
      ASSERT(NULL_PTR == o_pFlashDriverAddrStart);
      ASSERT(NULL_PTR == o_pFlashDriverEndAddr);


     // *o_pFlashDriverAddrStart = gs_astFlashDriverBlock[0u].xBlockStartLogicalAddr;
     // *o_pFlashDriverEndAddr = gs_astFlashDriverBlock[0u].xBlockEndLogicalAddr;

      return TRUE;
  }



  /*get erase flash sector max time*/
  uint32 FLASH_HAL_GetEraseFlashASectorMaxTimeMs(void)
  {


      return MAX_ERASE_SECTOR_FLASH_MS;
  }

  /*get total how much sectors in flash*/
  uint32 FLASH_HAL_GetTotalSectors(const tAPPType i_appType)
  {



      return 0;
  }

  /*Is APP type erased?*/
  boolean Flash_IsAPPTypeErased(const tAPPType i_erasedAPPType)
  {
      boolean res = FALSE;

      if((1u << i_erasedAPPType) & gs_stFlashDownloadInfo.erasedAPPFlag)
      {
          res = TRUE;
      }

      return res;
  }






  /*get 1 sector = bytes*/
  uint32 FLASH_HAL_Get1SectorBytes(void)
  {


      return SECTOR_LEN;
  }

  /*Is flash driver data?*/
  boolean Flash_IsFlashDriverData(const uint32 i_dataAddr, const uint32 i_dataLen)
  {
      uint32 flashDrvStartAddr = 0u;
      uint32 flashDrvEndAddr = 0u;
      boolean res = FALSE;

      res = FLASH_HAL_GetFlashDriverInfo(&flashDrvStartAddr, &flashDrvEndAddr);
      if(TRUE == res)
      {
          if((i_dataAddr >= flashDrvStartAddr) && ((i_dataAddr + i_dataLen) <= flashDrvEndAddr))
          {
              res = TRUE;
          }
          else
          {
              res = FALSE;
          }
      }

      return res;
  }


  /*Is download data address valid?*/
 uint8 UDS_IsDownloadDataAddrValid(const uint32 i_dataAddr, const uint32 i_dataLen)
  {


     return 0;
  }

 /*Flash program region. Called by uds servive 0x36u*/
 uint8 Flash_ProgramRegion(const uint32 i_addr,const uint8 *i_pDataBuf, const uint32 i_dataLen)
 {
    
     return 0;
 }

/*get operate flash active job*/
tFlshJobModle Flash_GetOperateFlashActiveJob(void)
{
    return gs_stFlashDownloadInfo.eActiveJob;
}

/*Do check newest app information*/
static tAPPType Flash_DoCheckNewestAPPInfo(const tAppFlashStatus * i_pAppAInfo, const tAppFlashStatus *i_pAppBInfo)
{

    uint32 crc = 0u;
    boolean bIsAppAValid = FALSE;
    boolean bIsAppBValid = FALSE;
    tAPPType newestAPP = APP_A_TYPE;

    ASSERT(NULL_PTR == i_pAppAInfo);
    ASSERT(NULL_PTR == i_pAppBInfo);

    CRC_HAL_CalculateCRCOnce((const uint8 *)i_pAppAInfo, sizeof(tAppFlashStatus) - 4u, &crc);
    if(crc == i_pAppAInfo->crc)
    {
        bIsAppAValid = TRUE;
    }

    CRC_HAL_CalculateCRCOnce((const uint8 *)i_pAppBInfo, sizeof(tAppFlashStatus) - 4u, &crc);
    if(crc == i_pAppBInfo->crc)
    {
        bIsAppBValid = TRUE;
    }

    if((TRUE == bIsAppAValid) && (TRUE != bIsAppBValid))
    {
        newestAPP = APP_A_TYPE;
    }
    else if((TRUE != bIsAppAValid) && (TRUE == bIsAppBValid))
    {
        newestAPP = APP_B_TYPE;
    }
    else if((TRUE != bIsAppAValid) && (TRUE != bIsAppBValid))
    {
        newestAPP = APP_A_TYPE;
    }
    else
    {
        /*check APP A and B who is newest, both APP A & B is valid*/
        newestAPP = Flash_DoCheckNewestAPPCnt(i_pAppAInfo, i_pAppBInfo);
    }

    return newestAPP;

}

static tAPPType Flash_GetNewestAPPType(void)
{

    uint32 appInfoStartAddr_A = 0u;
    uint32 appInfoBlockSize_A = 0u;
    tAPPType newestAPP = APP_A_TYPE;

    tAppFlashStatus appAInfo;
    tAppFlashStatus appBInfo;

    uint32 appInfoStartAddr_B = 0u;
    uint32 appInfoBlockSize_B = 0u;

    FLASH_HAL_GetAPPInfo(APP_A_TYPE, &appInfoStartAddr_A, &appInfoBlockSize_A);

    FLASH_HAL_GetAPPInfo(APP_B_TYPE, &appInfoStartAddr_B, &appInfoBlockSize_B);

    /*read APP A info*/
    appAInfo = *(tAppFlashStatus *)appInfoStartAddr_A;
    /*read APP B info*/
    appBInfo = *(tAppFlashStatus *)appInfoStartAddr_B;

    newestAPP = Flash_DoCheckNewestAPPInfo(&appAInfo, &appBInfo);

    return newestAPP;

}

/*Get old app info*/
tAPPType Flash_GetOldAPPType(void)
{

    uint32 appInfoStartAddr_A = 0u;
    uint32 appInfoBlockSize_A = 0u;
    tAPPType oldAPP = APP_A_TYPE;
    uint32 appInfoStartAddr_B = 0u;
    uint32 appInfoBlockSize_B = 0u;
    tAPPType newestAPP = APP_A_TYPE;
    tAppFlashStatus appAInfo;
    tAppFlashStatus appBInfo;

    FLASH_HAL_GetAPPInfo(APP_A_TYPE, &appInfoStartAddr_A, &appInfoBlockSize_A);

    FLASH_HAL_GetAPPInfo(APP_B_TYPE, &appInfoStartAddr_B, &appInfoBlockSize_B);

    /*read APP A info*/
    appAInfo = *(tAppFlashStatus *)appInfoStartAddr_A;

    /*read APP B info*/
    appBInfo = *(tAppFlashStatus *)appInfoStartAddr_B;


    newestAPP = Flash_DoCheckNewestAPPInfo(&appAInfo, &appBInfo);
    if(APP_A_TYPE == newestAPP)
    {
        oldAPP = APP_B_TYPE;
    }
    else if(APP_B_TYPE == newestAPP)
    {
        oldAPP = APP_A_TYPE;
    }
    else
    {
        /*here is set old APP type is default, just for error*/
        oldAPP = APP_A_TYPE;
    }

    return oldAPP;

}


static tAPPType Flash_DoCheckNewestAPPCnt(const tAppFlashStatus * i_pAppAInfo, const tAppFlashStatus *i_pAppBInfo)
{
    uint8 appACnt = 0u;
    uint8 appBCnt = 0u;
    uint8 deltaCnt = 0u;
    tAPPType newestAPP = APP_A_TYPE;

    ASSERT(NULL_PTR == i_pAppAInfo);
    ASSERT(NULL_PTR == i_pAppBInfo);

    appACnt = i_pAppAInfo->appCnt;
    appBCnt = i_pAppBInfo->appCnt;

    deltaCnt = (appACnt > appBCnt) ? (appACnt - appBCnt) : (appBCnt - appACnt);

    if(1u == deltaCnt)
    {
        if(appACnt > appBCnt)
        {
            newestAPP = APP_A_TYPE;
        }
        else
        {
            newestAPP = APP_B_TYPE;
        }
    }
    else if(0xFEu == deltaCnt)
    {
        if(appACnt < appBCnt)
        {
            newestAPP = APP_A_TYPE;
        }
        else
        {
            newestAPP = APP_B_TYPE;
        }
    }
    else
    {
        /*when cnt = 0xFF, then current cnt is invalid*/
        if((0xFFu == appACnt) && (0xFFu != appBCnt))
        {
            newestAPP = APP_B_TYPE;
        }
        else if((0xFFu != appACnt) && (0xFFu == appBCnt))
        {
            newestAPP = APP_A_TYPE;
        }
        else if((0xFFu == appACnt) && (0xFFu == appBCnt))
        {
            /*invalid conter*/
            newestAPP = APP_INVLID_TYPE;
        }
        else
        {
            newestAPP = APP_A_TYPE;
        }
    }

    return newestAPP;
}

/*write flash application information called by bootloader last step*/
 uint8 Flash_WriteFlashAppInfo(void)
 {
     uint8 result = FALSE;
     tAPPType oldAppType = APP_A_TYPE;
     uint32 appInfoStartAddr = 0u;
     uint32 appInfoLen = 0u;
     uint32 crc = 0u;
     tAppFlashStatus *pAppStatusPtr = NULL_PTR;

     tAPPType newestAPPType = APP_A_TYPE;
     uint32 newestAPPInfoStartAddr = 0u;
     uint32 newestAPPInfoLen = 0u;
     tAppFlashStatus *pstNewestAPPFlashStatus = NULL_PTR;
     uint32 resetHandleAddr = 0u;

     boolean bIsEnableWriteResetHandle = FALSE;
     uint32 resetHandleOffset = 0u;
     uint32 resetHandleLength = 0u;

     Flash_CreateAndSaveAppStatusCrc(&crc);

     oldAppType    = Flash_GetOldAPPType();
     newestAPPType = Flash_GetNewestAPPType();

     result = FLASH_HAL_GetAPPInfo(oldAppType, &appInfoStartAddr, &appInfoLen);
     if(TRUE == result)
     {
         /*write data information in flash*/
         pAppStatusPtr = Flash_GetAppStatusPtr();

         FLASH_HAL_GetRestHanlderInfo(&bIsEnableWriteResetHandle, &resetHandleOffset, &resetHandleLength);

         /*update APP cnt*/
         if(TRUE == FLASH_HAL_GetAPPInfo(newestAPPType, &newestAPPInfoStartAddr, &newestAPPInfoLen))
         {
             pstNewestAPPFlashStatus = (tAppFlashStatus *)newestAPPInfoStartAddr;

             pAppStatusPtr->appCnt = pstNewestAPPFlashStatus->appCnt + 1u;
             if(0xFFu == pAppStatusPtr->appCnt)
             {
                 pAppStatusPtr->appCnt = 0u;
             }

             /*get app start address from flash. The address is the newest APP, because the APP info not write in flash, so the APP is old*/
             resetHandleAddr = appInfoStartAddr + resetHandleOffset;

             Flash_SaveAppResetHandlerAddr(*((uint32*)resetHandleAddr), resetHandleLength);

             print("APP type =%X, APP address=0x%X\n", oldAppType, *((uint32*)resetHandleAddr));

             crc = 0u;
             Flash_CreateAndSaveAppStatusCrc(&crc);
         }

         if(NULL_PTR != pAppStatusPtr)
         {
             result = FALSE;

             if(NULL_PTR != gs_stFlashDownloadInfo.stFlashOperateAPI.pfProgramData)
             {
                 result = gs_stFlashDownloadInfo.stFlashOperateAPI.pfProgramData(appInfoStartAddr,
                                                     (uint8 *)pAppStatusPtr,sizeof(tAppFlashStatus));
             }

         }
         else
         {
             result = FALSE;
         }
     }

     return result;
 }

