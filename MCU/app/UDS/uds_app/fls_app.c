/**
 *
 * \copyright Copyright (c) 2019 Infineon Technologies AG. All rights reserved.
 *
 *
 *
 *                                 IMPORTANT NOTICE
 *
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such
 * terms of use are agreed, use of this file is subject to following:


 * Boost Software License - Version 1.0 - August 17th, 2003

 * Permission is hereby granted, free of charge, to any person or
 * organization obtaining a copy of the software and accompanying
 * documentation covered by this license (the "Software") to use, reproduce,
 * display, distribute, execute, and transmit the Software, and to prepare
 * derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:

 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.

 *
 */

/* Include Header Files ------------------------------------------------------*/

#include "fls_app.h"
#include "fl_cfc.h"
#include "uds_server.h"
#include "dflash.h"
#include "crc.h"

/** flashloader status information */
static  tEraseFlashStep                                 gs_eEraseFlashStep = START_ERASE_FLASH;
/*get current erase falsh step*/
#define Flash_GetCurEraseFlashStep()                     (gs_eEraseFlashStep)
#define Flash_SetEraseFlashStep(eEraseStep)              do{ gs_eEraseFlashStep = (eEraseStep);}while(0u)
/*Is request time successful?*/
static  uint8 gs_reqTimeStatus = 0xFFu;
extern  tFlsDownloadStateType                            gs_stFlashDownloadInfo;
extern  tAppFlashStatus                                  gs_stAppFlashStatus;
/*set request time status*/
#define Flash_ClearRequestTimeStauts()                   do{ gs_reqTimeStatus = 0xFFu; }while(0u)
#define Flash_SetRequestMoreTimeStatus(status)           do{ gs_reqTimeStatus = status; }while(0u)
#define Flash_IsReqestTimeSuccessfull()                  ((1u == gs_reqTimeStatus) ? TRUE : FALSE)
#define Flash_IsRequestTimeFailed()                      (((2u == gs_reqTimeStatus)) ? TRUE : FALSE)
#define REQ_TIME_SUCCESSFUL                              (1u)
#define REQ_TIME_FAILED                                  (2u)
static uint8 Flash_Erase(void);
static uint8 Flash_Write(void);
static uint8 Flash_Checksum(void);

/*Init flash download*/
void Flash_InitDowloadInfo(void)
{
    gs_stFlashDownloadInfo.isFingerPrintWritten = FALSE;
    if(TRUE == gs_stFlashDownloadInfo.isFlashDrvDownloaded)
    {
        gs_stFlashDownloadInfo.isFlashDrvDownloaded = TRUE;
    }

    Flash_SetNextDownloadStep(FL_REQUEST_STEP);
    Flash_SetOperateFlashActiveJob(FLASH_IDLE, NULL_PTR, INVALID_UDS_SERVICES_ID, NULL_PTR);
    gs_stFlashDownloadInfo.pstAppFlashStatus = &gs_stAppFlashStatus;
    memset(&gs_stFlashDownloadInfo.stFlashOperateAPI, 0x0u, sizeof(tFlashOperateAPI));
    memset(&gs_stAppFlashStatus, 0xFFu, sizeof(tAppFlashStatus));
}
/*Request mo retime sccessful from host.
**i_txMsgStatus: 0 is successful, others is failed.
*/
void RequetMoreTimeSuccessfulFromHost(uint8 i_txMsgStatus)
{
    if(0u == i_txMsgStatus)
    {
        /*request time successful*/
        Flash_SetRequestMoreTimeStatus(REQ_TIME_SUCCESSFUL);
    }
    else
    {
        /*tx message failed.*/
        Flash_SetRequestMoreTimeStatus(REQ_TIME_FAILED);
    }
}

/*flash operate main function*/
void Flash_OperateMainFunction(void)
{
    tFlshJobModle currentFlashJob = FLASH_IDLE;
    boolean bIsOperateFinshed = FALSE;

    currentFlashJob = Flash_GetOperateFlashActiveJob();

    switch (currentFlashJob)
    {
        case FLASH_ERASING:

            /* do the flash erase*/
            bIsOperateFinshed = FALSE;
            gs_stFlashDownloadInfo.errorCode = Flash_Erase();

            break;

        case FLASH_PROGRAMMING:

            bIsOperateFinshed = TRUE;
            /* do the flash program*/
            gs_stFlashDownloadInfo.errorCode = Flash_Write();

            break;

        case FLASH_CHECKING:

            /* do the flash checksum*/
            bIsOperateFinshed = TRUE;
            gs_stFlashDownloadInfo.errorCode = Flash_Checksum();

            break;

        case FLASH_WAITTING:

            if(TRUE == Flash_IsReqestTimeSuccessfull())
            {
                Flash_ClearRequestTimeStauts();

                Flash_RestoreInterruptedJob();
                Flash_RestoreOperateFlashActiveJob(FLASH_ERASING);
            }
            else if(TRUE == Flash_IsRequestTimeFailed())
            {
                Flash_ClearRequestTimeStauts();

                /*set erase flash step to start!*/
                Flash_SetEraseFlashStep(START_ERASE_FLASH);

                /* initialize the flash download state */
                Flash_InitDowloadInfo();

                /*set flash job is IDLE*/
                Flash_SetOperateFlashActiveJob(FLASH_IDLE, NULL_PTR, INVALID_UDS_SERVICES_ID, NULL_PTR);
            }
            else
            {
                /*do nothing*/

            }

            break;

        default:
            break;
    }

    /*just operate flash finshed, can do callback and set next job.*/
    if(TRUE == bIsOperateFinshed)
    {
        if((NULL_PTR != gs_stFlashDownloadInfo.pfActiveJobFinshedCallBack) && (FLASH_IDLE != currentFlashJob))
        {
            (gs_stFlashDownloadInfo.pfActiveJobFinshedCallBack)(gs_stFlashDownloadInfo.errorCode);

            gs_stFlashDownloadInfo.pfActiveJobFinshedCallBack = NULL_PTR;
        }

        if ((gs_stFlashDownloadInfo.errorCode != TRUE) &&
            ((FLASH_ERASING == currentFlashJob) ||
             (FLASH_PROGRAMMING == currentFlashJob) ||
             (FLASH_CHECKING == currentFlashJob)))
        {
            /* initialize the flash download state */
            Flash_InitDowloadInfo();
        }

        /*set flash job is IDLE*/
        Flash_SetOperateFlashActiveJob(FLASH_IDLE, NULL_PTR, INVALID_UDS_SERVICES_ID, NULL_PTR);
    }
}


/* Fash Erase*/
static uint8 Flash_Erase(void)
{

    uint8  s_result = -1;
    static tAPPType s_appType = APP_INVLID_TYPE;
    static const FL_DescriptorType *o_pAppInfoStartAddr = NULL;
    static FlashOpera_t tFlashOpera;
    static uint32 erasecount=0;
    static uint32 erasec=0;

    //根据存入的info 信息判断哪个区域是最新的镜像，从而擦除老的区域
    //这里只预留双bank程序，实际不实现双bank
    /*check flash driver valid or not?*/
    switch(Flash_GetCurEraseFlashStep())
    {

     case START_ERASE_FLASH:
      /*get old app type*/
       s_appType = Flash_GetOldAPPType();

       if( FLASH_HAL_GetFlashBankInfo(s_appType, &o_pAppInfoStartAddr) ==TRUE )
       {
          if(o_pAppInfoStartAddr!=NULL)
          {
            memset(&tFlashOpera,0,sizeof(tFlashOpera));

            Flash_SetEraseFlashStep(DO_ERASING_FLASH);
          }
       }

       break;

     case DO_ERASING_FLASH:

       for(uint8 i = 0;i < PBLK_NUM_MAX;i++)
       {
          s_result =  HAL_GetFlashOperationInfo(o_pAppInfoStartAddr[i].address, o_pAppInfoStartAddr[i].endaddress, &tFlashOpera);

          if (s_result != 0)
          {
              Flash_SetEraseFlashStep(END_ERASE_FLASH);
              return s_result;
          }

          erasec = tFlashOpera.startSector;

          if (erasec > tFlashOpera.endSector)
          {
              Flash_SetEraseFlashStep(END_ERASE_FLASH);
              return 0xFE;
          }

          while(erasec <= tFlashOpera.endSector)
          {
             s_result= Hal_Flash_Erase(&tFlashOpera,erasec);

             if( s_result!=0 )
             {
                //擦除失败，放弃擦除
                //发送失败
                 erasec=0;
                Flash_SetEraseFlashStep(END_ERASE_FLASH);
                return s_result;
             }

             erasecount++;
             erasec++;

             if(tFlashOpera.eFlashType==FLASH_TYPE_P_FLASH)
             {
               if( (erasecount % 2) == 0 )
               {
                   //喂狗
               }

             }else if(tFlashOpera.eFlashType==FLASH_TYPE_D_FLASH)
             {
               if( (erasecount % 8) == 0 )
               {
                  //喂狗
               }

             }else{

                Flash_SetEraseFlashStep(END_ERASE_FLASH);
                return 0xFF;
              }
          }

       }

       if( s_result == 0)
       {
           gs_stAppFlashStatus.isFlashErasedSuccessfull=TRUE;
           gs_stAppFlashStatus.isFlashProgramSuccessfull=FALSE;
           gs_stAppFlashStatus.isFlashStructValid=TRUE;

           Flash_SetAPPTypeErased(s_appType);
       }else{
           gs_stAppFlashStatus.isFlashErasedSuccessfull=FALSE;
           gs_stAppFlashStatus.isFlashProgramSuccessfull=FALSE;
           gs_stAppFlashStatus.isFlashStructValid=TRUE;

           Flash_ClearAPPTypeErased(s_appType);
       }

       Flash_SetEraseFlashStep(END_ERASE_FLASH);

       return s_result;

       break;

      case END_ERASE_FLASH:

        erasecount=0;
        erasec=0;
        o_pAppInfoStartAddr=NULL;
        memset(&tFlashOpera, 0, sizeof(tFlashOpera));

        Flash_SetEraseFlashStep(START_ERASE_FLASH);

        break;

      default:

        Flash_SetEraseFlashStep(START_ERASE_FLASH);

        break;
    }

   return s_result;
}


/*flash write */
static uint8 Flash_Write(void)
{
    uint8 result = FALSE;
    uint8 tempRet = 0u;
    uint32 countCrc = 0u;
    uint8 flashDataIndex = 0u;
    uint8 fillCnt = 0u;

    /*check flash driver valid or not?*/
    if(TRUE != gs_stFlashDownloadInfo.isFlashDrvDownloaded)
    {
        return FALSE;
    }

    result = TRUE;
    while(gs_stFlashDownloadInfo.receiveProgramDataLength >= PROGRAM_SIZE)
    {
        /*count application flash crc*/
        Flash_CreateAppStatusCrc(&countCrc);
        if(TRUE != Flash_IsFlashAppCrcEqualStorage(countCrc))
        {
            /*crc not right*/
            result = FALSE;

            break;
        }

        if((TRUE == gs_stAppFlashStatus.isFlashErasedSuccessfull) &&
           (TRUE == gs_stAppFlashStatus.isFlashStructValid))
        {
           // WATCHDOG_HAL_Fed();

            /*write data in flash*/

            DisableAllInterrupts();
            tempRet = Hal_Flash_write(gs_stFlashDownloadInfo.startAddr,
                                         &gs_stFlashDownloadInfo.aProgramDataBuff[flashDataIndex * PROGRAM_SIZE],
                                         PROGRAM_SIZE);
            EnableAllInterrupts();
            if(0 == tempRet)
            {
                gs_stFlashDownloadInfo.length -= PROGRAM_SIZE;
                gs_stFlashDownloadInfo.receiveProgramDataLength -= PROGRAM_SIZE;
                gs_stFlashDownloadInfo.startAddr += PROGRAM_SIZE;

                flashDataIndex++;
                result=TRUE;
            }
            else
            {
                result = FALSE;

                break;
            }
        }
        else
        {
            result = FALSE;

            break;
        }
    }

    /*calculate if program data is align < 8 bytes, need to fill 0xFF to align 8 bytes.*/
    if((0u != gs_stFlashDownloadInfo.receiveProgramDataLength) && (TRUE == result))
    {
        fillCnt = (uint8)(gs_stFlashDownloadInfo.receiveProgramDataLength & 0x07u);
        fillCnt = (~fillCnt + 1u) & 0x07u;

        memset((void *)&gs_stFlashDownloadInfo.aProgramDataBuff[flashDataIndex * PROGRAM_SIZE + gs_stFlashDownloadInfo.receiveProgramDataLength],
                    0xFFu,
                    fillCnt);

        gs_stFlashDownloadInfo.receiveProgramDataLength += fillCnt;

        /*write data in flash*/
       DisableAllInterrupts();
       tempRet = Hal_Flash_write(gs_stFlashDownloadInfo.startAddr,
                                         &gs_stFlashDownloadInfo.aProgramDataBuff[flashDataIndex * PROGRAM_SIZE],
                                         gs_stFlashDownloadInfo.receiveProgramDataLength);
       EnableAllInterrupts();

        if(0 == tempRet)
        {
            gs_stFlashDownloadInfo.length -= (gs_stFlashDownloadInfo.receiveProgramDataLength - fillCnt);
            gs_stFlashDownloadInfo.startAddr += gs_stFlashDownloadInfo.receiveProgramDataLength;
            gs_stFlashDownloadInfo.receiveProgramDataLength = 0;

            flashDataIndex++;
            result=TRUE;
        }

    }

    if(TRUE == result)
    {
        gs_stAppFlashStatus.isFlashProgramSuccessfull = TRUE;
        Flash_CreateAndSaveAppStatusCrc(countCrc);

        return TRUE;
    }

    Flash_InitDowloadInfo();

    return FALSE;
}


/*flash check sum */
static uint8 Flash_Checksum(void)
{
    tChecksumStep checksumStep = START_CHECKSUM;
	uint8 isSuccessful = FALSE;
	static uint32 s_xCountCrc = 0u;
	boolean isOperateFinsh = FALSE;
	static uint32 s_calCRCDataLen = 0u;
	uint32 startCalDataAddr = 0u;
	uint32 calCRCDataLen = 0u;
	
	//喂狗

	isSuccessful = TRUE;
	checksumStep = Flash_GetChecksumStep();
	switch(checksumStep)
	{
		case START_CHECKSUM:
			
			CRC_HAL_StartSoftwareCrc(&s_xCountCrc);
			s_calCRCDataLen = 0u;
			Flash_SetChecksumStep(DO_CHECKING_CHECKSUM);

			break;

		case DO_CHECKING_CHECKSUM:

			if((gs_stFlashDownloadInfo.receivedDataLength - s_calCRCDataLen) >= MAX_ONCE_CHECKSUM_SIZE)
			{
				calCRCDataLen = MAX_ONCE_CHECKSUM_SIZE;
			}
			else
			{
				calCRCDataLen = gs_stFlashDownloadInfo.receivedDataLength - s_calCRCDataLen;
			}

			startCalDataAddr = gs_stFlashDownloadInfo.receivedDataStartAddr + s_calCRCDataLen;
			
			CRC_HAL_CreatSoftwareCrc((const uint8 *)startCalDataAddr, calCRCDataLen, &s_xCountCrc);

			s_calCRCDataLen += calCRCDataLen;
			if(s_calCRCDataLen == gs_stFlashDownloadInfo.receivedDataLength)
			{
				Flash_SetChecksumStep(END_CHECKSUM);
			}
			else
			{
				/*request more time*/
				Flash_RegInterruptedJob(FLASH_CHECKING);
				Flash_RestoreOperateFlashActiveJob(FLASH_WAITTING);
				
				/*request more time from host*/
				if(NULL_PTR != gs_stFlashDownloadInfo.pfRequestMoreTime)
				{
					gs_stFlashDownloadInfo.pfRequestMoreTime(gs_stFlashDownloadInfo.requestActiveJobUDSSerID, RequetMoreTimeSuccessfulFromHost);
				}				
			}

			break;

		case END_CHECKSUM:
			
			CRC_HAL_EndSoftwareCrc(&s_xCountCrc);
			Flash_SaveCalculateCRCValue(s_xCountCrc);
			isOperateFinsh = TRUE;

			Flash_SetChecksumStep(START_CHECKSUM);
			break;

		default:

			Flash_SetChecksumStep(START_CHECKSUM);
			isSuccessful = FALSE;
			isOperateFinsh = TRUE;
			
			break;
	}

	//喂狗

	if(TRUE != isSuccessful)
	{
		print("%s: checksum job failed!\n", __func__);
		
		return isSuccessful;
	}

	return isSuccessful;	
}







