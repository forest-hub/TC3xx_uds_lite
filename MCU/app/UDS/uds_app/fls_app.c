/**
 *
 * \copyright Copyright (c) 2019 Infineon Technologies AG. All rights reserved.
 *
 *
 *
 *                                 IMPORTANT NOTICE
 *
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such
 * terms of use are agreed, use of this file is subject to following:


 * Boost Software License - Version 1.0 - August 17th, 2003

 * Permission is hereby granted, free of charge, to any person or
 * organization obtaining a copy of the software and accompanying
 * documentation covered by this license (the "Software") to use, reproduce,
 * display, distribute, execute, and transmit the Software, and to prepare
 * derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:

 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.

 *
 */

/* Include Header Files ------------------------------------------------------*/

#include "fls_app.h"
#include "fl_cfc.h"
#include "uds_server.h"
#include "dflash.h"

/** flashloader status information */
/*request time status define*/
#define REQ_TIME_SUCCESSFUL (1u)

/*request time failed*/
#define REQ_TIME_FAILED     (2u)
static tEraseFlashStep gs_eEraseFlashStep = START_ERASE_FLASH;
/*get current erase falsh step*/
#define Flash_GetCurEraseFlashStep()              (gs_eEraseFlashStep)
#define Flash_SetEraseFlashStep(eEraseStep)       do{  gs_eEraseFlashStep = (eEraseStep);}while(0u)
/*Is request time successful?*/
static uint8 gs_reqTimeStatus = 0xFFu;
extern tFlsDownloadStateType                   gs_stFlashDownloadInfo;
extern tAppFlashStatus                         gs_stAppFlashStatus;
/*set request time status*/
#define Flash_ClearRequestTimeStauts()            do{ gs_reqTimeStatus = 0xFFu;}while(0u)
#define Flash_SetRequestMoreTimeStatus(status)    do{ gs_reqTimeStatus = status;}while(0u)
#define Flash_IsReqestTimeSuccessfull()           ((1u == gs_reqTimeStatus) ? TRUE : FALSE)
#define Flash_IsRequestTimeFailed()               (((2u == gs_reqTimeStatus)) ? TRUE : FALSE)

static uint8 Flash_Erase(boolean * o_pbIsOperateFinsh);
static uint8 Flash_Write(boolean * o_pbIsOperateFinsh);
static uint8 Flash_Checksum(boolean * o_pbIsOperateFinsh);

/*Request mo retime sccessful from host.
**i_txMsgStatus: 0 is successful, others is failed.
*/
static void RequetMoreTimeSuccessfulFromHost(uint8 i_txMsgStatus)
{
    if(0u == i_txMsgStatus)
    {
        /*request time successful*/
        Flash_SetRequestMoreTimeStatus(REQ_TIME_SUCCESSFUL);
    }
    else
    {
        /*tx message failed.*/
        Flash_SetRequestMoreTimeStatus(REQ_TIME_FAILED);
    }
}

/*get operate flash active job*/
tFlshJobModle Flash_GetOperateFlashActiveJob(void)
{
    return gs_stFlashDownloadInfo.eActiveJob;
}

/*restore operate flash active job*/
static void Flash_RestoreOperateFlashActiveJob(const tFlshJobModle i_activeJob)
{
    gs_stFlashDownloadInfo.eActiveJob = i_activeJob;
}

/*Init flash download*/
void Flash_InitDowloadInfo(void)
{
    gs_stFlashDownloadInfo.isFingerPrintWritten = FALSE;

    if(TRUE == gs_stFlashDownloadInfo.isFlashDrvDownloaded)
    {
        Flash_EraseFlashDriverInRAM();

        gs_stFlashDownloadInfo.isFlashDrvDownloaded = TRUE;
    }

    Flash_SetNextDownloadStep(FL_REQUEST_STEP);

    Flash_SetOperateFlashActiveJob(FLASH_IDLE, NULL_PTR, INVALID_UDS_SERVICES_ID, NULL_PTR);

    gs_stFlashDownloadInfo.pstAppFlashStatus = &gs_stAppFlashStatus;

    memset(&gs_stFlashDownloadInfo.stFlashOperateAPI, 0x0u, sizeof(tFlashOperateAPI));

    memset(&gs_stAppFlashStatus, 0xFFu, sizeof(tAppFlashStatus));
}

/*flash operate main function*/
void Flash_OperateMainFunction(void)
{
    tFlshJobModle currentFlashJob = FLASH_IDLE;
    boolean bIsOperateFinshed = FALSE;

    currentFlashJob = Flash_GetOperateFlashActiveJob();

    switch (currentFlashJob)
    {
        case FLASH_ERASING:

            /* do the flash erase*/
            bIsOperateFinshed = FALSE;
            gs_stFlashDownloadInfo.errorCode = Flash_Erase(&bIsOperateFinshed);

            break;

        case FLASH_PROGRAMMING:

            bIsOperateFinshed = TRUE;

            /* do the flash program*/
            gs_stFlashDownloadInfo.errorCode = Flash_Write(&bIsOperateFinshed);

            break;

        case FLASH_CHECKING:

            /* do the flash checksum*/
            bIsOperateFinshed = TRUE;
            gs_stFlashDownloadInfo.errorCode = Flash_Checksum(&bIsOperateFinshed);

            break;

        case FLASH_WAITTING:

            if(TRUE == Flash_IsReqestTimeSuccessfull())
            {
                Flash_ClearRequestTimeStauts();

             //   Flash_RestoreInterruptedJob();
                Flash_RestoreOperateFlashActiveJob(FLASH_ERASING);
            }
            else if(TRUE == Flash_IsRequestTimeFailed())
            {
                Flash_ClearRequestTimeStauts();

                /*set erase flash step to start!*/
                 Flash_SetEraseFlashStep(START_ERASE_FLASH);

                /* initialize the flash download state */
                Flash_InitDowloadInfo();

                /*set flash job is IDLE*/
                Flash_SetOperateFlashActiveJob(FLASH_IDLE, NULL_PTR, INVALID_UDS_SERVICES_ID, NULL_PTR);
            }
            else
            {
                /*do nothing*/

            }

            break;

        default:
            break;
    }

    /*just operate flash finshed, can do callback and set next job.*/
    if(TRUE == bIsOperateFinshed)
    {
        if((NULL_PTR != gs_stFlashDownloadInfo.pfActiveJobFinshedCallBack) && (FLASH_IDLE != currentFlashJob))
        {
            (gs_stFlashDownloadInfo.pfActiveJobFinshedCallBack)(gs_stFlashDownloadInfo.errorCode);

            gs_stFlashDownloadInfo.pfActiveJobFinshedCallBack = NULL_PTR;
        }

        if ((gs_stFlashDownloadInfo.errorCode != TRUE) &&
            ((FLASH_ERASING == currentFlashJob) ||
             (FLASH_PROGRAMMING == currentFlashJob) ||
             (FLASH_CHECKING == currentFlashJob)))
        {
            /* initialize the flash download state */
            Flash_InitDowloadInfo();
        }

        /*set flash job is IDLE*/
        Flash_SetOperateFlashActiveJob(FLASH_IDLE, NULL_PTR, INVALID_UDS_SERVICES_ID, NULL_PTR);
    }
}




/* Fash Erase*/
static uint8 Flash_Erase(boolean * o_pbIsOperateFinsh)
{
   

    return 0;
}


/*flash write */
static uint8 Flash_Write(boolean * o_pbIsOperateFinsh)
{
    

    return 0;
}


/*flash check sum */
static uint8 Flash_Checksum(boolean * o_pbIsOperateFinsh)
{


    return 0;
}







