/**
 *
 * \copyright Copyright (c) 2019 Infineon Technologies AG. All rights reserved.
 *
 *
 *
 *                                 IMPORTANT NOTICE
 *
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such
 * terms of use are agreed, use of this file is subject to following:


 * Boost Software License - Version 1.0 - August 17th, 2003

 * Permission is hereby granted, free of charge, to any person or
 * organization obtaining a copy of the software and accompanying
 * documentation covered by this license (the "Software") to use, reproduce,
 * display, distribute, execute, and transmit the Software, and to prepare
 * derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:

 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.

 *
 */

/* Include Header Files ------------------------------------------------------*/

#include "fls_app.h"
#include "fl_cfc.h"
#include "SecM.h"
#include "uds_server.h"
const uint8 BL_Information[FL_NUM_LOGICAL_BLOCKS * 20 + 4] = {0x00};
extern const FL_BlockDescriptorType FL_BlkInfo[FL_NUM_LOGICAL_BLOCKS];
static uint8 FlProgramData[FL_PROGRAM_SIZE];
static uint32 FlProgramLength = 0UL;
static FL_RemainDataType FL_RemainDataStruct = { 0UL, 0UL};
/** flashloader status information */
/*request time status define*/
#define REQ_TIME_SUCCESSFUL (1u)

/*request time failed*/
#define REQ_TIME_FAILED (2u)
/*Is request time successful?*/
static uint8 gs_reqTimeStatus = 0xFFu;
/*set request time status*/
#define Flash_ClearRequestTimeStauts()\
do{\
    gs_reqTimeStatus = 0xFFu;\
}while(0u)

/*request more time successful*/
#define Flash_SetRequestMoreTimeStatus(status) \
do{\
    gs_reqTimeStatus = status;\
}while(0u)
/*Is request time successfull?*/
#define Flash_IsReqestTimeSuccessfull() ((1u == gs_reqTimeStatus) ? TRUE : FALSE)

#define Flash_IsRequestTimeFailed() (((2u == gs_reqTimeStatus)) ? TRUE : FALSE)
static FL_DownloadStateType FldownloadStatus;
FL_NvmInfoType FL_NvmInfo;
static tFlashParam flashParamInfo =
    {
        (uint8)FLASH_DRIVER_VERSION_PATCH,
        (uint8)FLASH_DRIVER_VERSION_MINOR,
        (uint8)FLASH_DRIVER_VERSION_MAJOR,
        (uint8)0x00u,
        (uint8)kFlashOk,
        (uint16)0x0000U,
        0UL,
        0UL,
        NULL_PTR,
        NULL_PTR
    };



void FL_InitState(void)
{
#if BL_NvmInf
    uint8 i = 0;
    if ((0 == i) && (0 == BL_Information[0]))
    {
        i = 1;
    }
#endif

    /* finger print is not written to NVM*/
    FldownloadStatus.fingerPrintWrittenFlag = FALSE;
    /* finger print is not written */
    FldownloadStatus.fingerPrintWritten = FALSE;

    /* flash driver is not downloaded */
    FldownloadStatus.flDrvDownloaded = FALSE;

    /* current block is not erased */
    FldownloadStatus.blockErased = FALSE;

    /* download step is download request 0x34 */
    FldownloadStatus.downloadStep = FL_REQUEST_STEP;

    /* current active job is idle */
    FldownloadStatus.activeJob = FL_JOB_IDLE;

    FL_RemainDataStruct.remainLength = 0UL;

    return;
}

/*Request mo retime sccessful from host.
**i_txMsgStatus: 0 is successful, others is failed.
*/
static void RequetMoreTimeSuccessfulFromHost(uint8 i_txMsgStatus)
{
    if(0u == i_txMsgStatus)
    {
        /*request time successful*/
        Flash_SetRequestMoreTimeStatus(REQ_TIME_SUCCESSFUL);
    }
    else
    {
        /*tx message failed.*/
        Flash_SetRequestMoreTimeStatus(REQ_TIME_FAILED);
    }
}

/******************************************************************************/
/**
 * @brief               <fill pad>
 *
 * <fill the pad between segments of current block> .
 * @param[in]           <NONE>
 * @param[out]          <NONE>
 * @param[in/out]       <NONE>
 * @return              <FL_ResultType>
 */
/******************************************************************************/


#if (FL_USE_GAP_FILL)
static uint8 FL_FillGap(void)
{
    uint8 ret = FL_OK;
    uint8 segmentIndex = 0;
    uint32 startAddress = FL_BlkInfo[FldownloadStatus.blockIndex].address;
    uint32 gapLength;

    /* set the download data with FL_GAP_FILL_VALUE */
    memset((uint8 *)&FlProgramData[0], (uint8)FL_GAP_FILL_VALUE, (uint32)FL_PROGRAM_SIZE);

    flashParamInfo.data = (uint8 *)&FlProgramData[0];

    while ((segmentIndex <= FldownloadStatus.segmentList.nrOfSegments) && (FL_OK == ret))
    {
        /* find the length of the gap in the segment */
        if (segmentIndex < FldownloadStatus.segmentList.nrOfSegments)
        {
            gapLength = FldownloadStatus.segmentList.segmentInfo[segmentIndex].address - startAddress;
        }
        else
        {
            gapLength = (FL_BlkInfo[FldownloadStatus.blockIndex].address + FL_BlkInfo[FldownloadStatus.blockIndex].length) - startAddress;
        }

        gapLength &= ~(FL_FLASH_ALIGN_SIZE - 1);

        /* set the flash download address of gap */
        flashParamInfo.address = startAddress;

        while ((gapLength > 0) && (FL_OK == ret))
        {
            if (gapLength >= FL_PROGRAM_SIZE)
            {
                /* set the download length */
                flashParamInfo.length = FL_PROGRAM_SIZE;

                /* update the gap length */
                gapLength -= FL_PROGRAM_SIZE;
            }
            else
            {
                /* the last gap */
                flashParamInfo.length = gapLength;
                gapLength = 0;
            }

            /* write the flash of the FlashParam for gap */

            Hal_Flash_write(flashParamInfo.address, flashParamInfo.data, flashParamInfo.length);
            flashParamInfo.address += flashParamInfo.length;

            /* check if program pad success */
            if (flashParamInfo.errorCode != kFlashOk)
            {
                ret = FL_FAILED;
            }
        }

        if (segmentIndex < FldownloadStatus.segmentList.nrOfSegments)
        {
            /* set the next start address */
            startAddress = FldownloadStatus.segmentList.segmentInfo[segmentIndex].address + FldownloadStatus.segmentList.segmentInfo[segmentIndex].length;

            if ((startAddress & (FL_FLASH_ALIGN_SIZE - 1)) > 0)
            {
                startAddress &= ~(FL_FLASH_ALIGN_SIZE - 1);
                startAddress += FL_FLASH_ALIGN_SIZE;
            }
        }

        segmentIndex++;
    }

    return ret;
}
#endif


/******************************************************************************/
/**
 * @brief               <program data>
 *
 * <program the aligned data transfered by 0x36 service request > .
 * @param[in]           <NONE>
 * @param[out]          <NONE>
 * @param[in/out]       <NONE>
 * @return              <FL_ResultType>
 */
/******************************************************************************/
static uint8 FL_ProgrammingData(void)
{
    uint8 ret = (uint8)FL_OK;

    /* check the program length and program status */
    while ((FlProgramLength > 0UL) && ((uint8)FL_OK == ret))
    {
        /* check if the program size is more than maximum size of program buffer */
        if ((FlProgramLength + FL_RemainDataStruct.remainLength) >= (uint32)FL_PROGRAM_SIZE)
        {
            /* get the download data */
            memcpy(&FlProgramData[FL_RemainDataStruct.remainLength],
                        FldownloadStatus.dataBuff,
                        (uint32)FL_PROGRAM_SIZE - FL_RemainDataStruct.remainLength);

            /* index the databuff point in transfered buffer */
            FldownloadStatus.dataBuff += FL_PROGRAM_SIZE - FL_RemainDataStruct.remainLength;

            /* index the total program length */
            FlProgramLength -= FL_PROGRAM_SIZE - FL_RemainDataStruct.remainLength;

            /* set the flash driver input parameter */
            flashParamInfo.address = FldownloadStatus.startAddr - FL_RemainDataStruct.remainLength;
            flashParamInfo.length = (uint32)FL_PROGRAM_SIZE;
            flashParamInfo.data = &FlProgramData[0];

            /* program the data */
            Hal_Flash_write(flashParamInfo.address, flashParamInfo.data, flashParamInfo.length);

            /* index the start address and length that record in 0x34 service */
            FldownloadStatus.startAddr += FL_PROGRAM_SIZE - FL_RemainDataStruct.remainLength;
            FldownloadStatus.downLength -= FL_PROGRAM_SIZE - FL_RemainDataStruct.remainLength;
            FL_RemainDataStruct.remainAddr = FldownloadStatus.startAddr;
            FL_RemainDataStruct.remainLength = 0x00U;
            /* check if program success */
            if (flashParamInfo.errorCode != (uint8)kFlashOk)
            {
                ret = (uint8)FL_FAILED;
            }
            else
            {
                /* empty */
            }
        }
        else
        {
            /* set the last data for write of current service 0x36 */
            memcpy(&FlProgramData[FL_RemainDataStruct.remainLength],
                        FldownloadStatus.dataBuff,
                        FlProgramLength);
            FL_RemainDataStruct.remainAddr = FldownloadStatus.startAddr - FL_RemainDataStruct.remainLength;
            FL_RemainDataStruct.remainLength += FlProgramLength;
            /* index the start address and length that record in 0x34 service */
            FldownloadStatus.startAddr += FlProgramLength;
            FldownloadStatus.downLength -= FlProgramLength;
            /* end of current service 0x36 */
            FlProgramLength = 0UL;
        }
    }

    return ret;
}

/******************************************************************************/
/**
 * @brief               <program bootloader infomation to EEPROM>
 *
 * <program bootloader infomation to EEPROM,e.g. block valid,checksum,
 *  fingerprint..> .
 * @param[in]           <NONE>
 * @param[out]          <NONE>
 * @param[in/out]       <NONE>
 * @return              <FL_ResultType>
 */
/******************************************************************************/
static uint8 FL_UpdateNvm(void)
{
    uint8 ret = (uint8)FL_FAILED;
    /* CRC32 parameter */
    SecM_CRCParamType crcParam;

    /* Initialize CRC32 parameter */
    crcParam.crcState = (uint8)SECM_CRC_INIT;
    crcParam.crcSourceBuffer = (const uint8 *)&FL_NvmInfo;
    crcParam.crcByteCount = (uint16)(sizeof(FL_NvmInfoType) - (uint8)4);

    /* compute CRC of the block information */
    (void)SecM_ComputeCRC(&crcParam);
    crcParam.crcState = (uint8)SECM_CRC_COMPUTE;
    (void)SecM_ComputeCRC(&crcParam);
    crcParam.crcState = (uint8)SECM_CRC_FINALIZE;
    (void)SecM_ComputeCRC(&crcParam);

    /* program computed CRC value to flash */
    FL_NvmInfo.infoChecksum = crcParam.currentCRC;

    /* set input parameter of flash driver interface */
    flashParamInfo.data = (const uint8 *)&FL_NvmInfo;
    flashParamInfo.address = FL_NVM_INFO_ADDRESS;
    flashParamInfo.length = (uint32)sizeof(FL_NvmInfoType);

    /* erase flash block witch store the blocks information */
    Hal_Flash_Erase(flashParamInfo.address, flashParamInfo.length);
    if ((uint8)kFlashOk == flashParamInfo.errorCode)
    {
        /* program blocks information */
        flashParamInfo.length = (uint32)sizeof(FL_NvmInfoType);

        Hal_Flash_write(flashParamInfo.address, flashParamInfo.data, flashParamInfo.length);
    }
    else
    {
        /* empty */
    }

    if ((uint8)kFlashOk == flashParamInfo.errorCode)
    {
        /* finger print is not written to NVM*/
        FldownloadStatus.fingerPrintWrittenFlag = TRUE;

        ret = (uint8)FL_OK;
    }
    else
    {
        /* empty */
    }

    return ret;
}

static uint8 FL_Erasing(void)
{
    uint8 ret = (uint8)FL_OK;
    uint32 tempLength;
    uint8 pendingIndex = 0u;
    /* update the bootloader information to EEPROM */
    ret = FL_UpdateNvm();

    if ((uint8)FL_OK == ret)
    {
        /* set flash driver input parameter */
        flashParamInfo.address = FL_BlkInfo[FldownloadStatus.blockIndex].address;
        flashParamInfo.length = FL_BlkInfo[FldownloadStatus.blockIndex].length;

        if (flashParamInfo.length <= 0x30000U)
        {
            /* erase the flash of the requested block */
            Hal_Flash_Erase(flashParamInfo.address, flashParamInfo.length);
        }
        else
        {
            tempLength = flashParamInfo.length - 0x30000U;
            flashParamInfo.length = 0x30000U;
            Hal_Flash_Erase(flashParamInfo.address, flashParamInfo.length);
            flashParamInfo.address += flashParamInfo.length;
            /* force sending pending */
            UDS_RequestMoreTime(31,RequetMoreTimeSuccessfulFromHost);

            while (((uint8)kFlashOk == flashParamInfo.errorCode) && (tempLength > 0x40000u) && (flashParamInfo.address < 0xA0200000u))
            {
                pendingIndex++;
                flashParamInfo.length = 0x40000U;
                Hal_Flash_Erase(flashParamInfo.address, flashParamInfo.length);
                flashParamInfo.address += flashParamInfo.length;
                tempLength -= 0x40000U;

                if (2u == pendingIndex)
                {
                    pendingIndex = 0u;
                    /* force sending pending */
                    UDS_RequestMoreTime(31,RequetMoreTimeSuccessfulFromHost);

                }
            }

            if (flashParamInfo.address >= 0xA0200000u)
            {
                /* force sending pending */
                UDS_RequestMoreTime(31,RequetMoreTimeSuccessfulFromHost);


                pendingIndex = 0u;
                while (((uint8)kFlashOk == flashParamInfo.errorCode) && (tempLength >= 0x40000U))
                {
                    pendingIndex++;

                    flashParamInfo.length = 0x40000U;
                    Hal_Flash_Erase(flashParamInfo.address, flashParamInfo.length);
                    flashParamInfo.address += flashParamInfo.length;
                    tempLength -= 0x40000U;
                    if (2u == pendingIndex)
                    {
                        pendingIndex = 0u;
                        /* force sending pending */
                        UDS_RequestMoreTime(31,RequetMoreTimeSuccessfulFromHost);


                    }
                }
            }
        }

        /* check if erase success */
        if ((uint8)kFlashOk == flashParamInfo.errorCode)
        {
            /* set the block erased */
            FldownloadStatus.blockErased = TRUE;
        }
        else
        {
            ret = (uint8)FL_FAILED;
        }
    }
    else
    {
        /* empty */
    }

    return ret;
}

/******************************************************************************/
/**
 * @brief               <active job program>
 *
 * <program the data transfered by 0x36 service request > .
 * @param[in]           <NONE>
 * @param[out]          <NONE>
 * @param[in/out]       <NONE>
 * @return              <FL_ResultType>
 */
/******************************************************************************/
static uint8 FL_Programming(void)
{
    uint8 ret = (uint8)FL_OK;

    /* program buffer aligned data */
    ret = FL_ProgrammingData();

    /* check if the last not aligned data should be programmed */
    if ((0UL == FldownloadStatus.downLength) && ((uint8)FL_OK == ret))
    {
        FldownloadStatus.downloadStep = FL_EXIT_TRANSFER_STEP;
    }
    else
    {
        /* empty */
    }

    return ret;
}


static uint8 FL_CheckSuming(void)
{
    uint8 ret = (uint8)FL_OK;
    uint8 secMStatus;
    SecM_VerifyParamType verifyParam;

    /* set verification API input parameter */
    verifyParam.segmentList = &FldownloadStatus.segmentList;
    verifyParam.verificationData = FldownloadStatus.dataBuff;

    /* CRC compute and verification */
    secMStatus = SecM_Verification(&verifyParam);

    /* set block not erased */
    FldownloadStatus.blockErased = FALSE;

    /* check if CRC if correct */
    if (SECM_OK == secMStatus)
    {
        /* check if flash driver is downloaded */
        if (FALSE == FldownloadStatus.flDrvDownloaded)
        {
            /* flash driver initialize */
           // BLFlash_InfoPtr->flashInitFct(&flashParamInfo);
            flashParamInfo.errorCode = kFlashOk;
            /* check if flash driver is initialized success */
            if (flashParamInfo.errorCode != (uint8)kFlashOk)
            {
                ret = (uint8)FL_FAILED;
            }
            else
            {
                FldownloadStatus.flDrvDownloaded = TRUE;
            }
        }
        else
        {
            /* set current block is valid */
            FL_NvmInfo.blockInfo[FldownloadStatus.blockIndex].blkValid = TRUE;

            /* save computed CRC to NVM if CRC success */
            FL_NvmInfo.blockInfo[FldownloadStatus.blockIndex].blkChecksum = verifyParam.crcTotle;

            /* fill the gap if configured */
#if   (FL_USE_GAP_FILL)
            ret = FL_FillGap();

            if ((uint8)FL_OK == ret)
#endif
            {
                /* response pending (7F 2E 78) during updating nvm */
                FldownloadStatus.errorCode = (uint8)FL_UPDATING_NVM;

                /* update nvm */
                ret = FL_UpdateNvm();
            }

            /* check if EEPROM UPDATE failed */
            if (ret != (uint8)FL_OK)
            {
                FL_NvmInfo.blockInfo[FldownloadStatus.blockIndex].blkValid = FALSE;
            }
            else
            {
                /* empty */
            }
        }
    }
    else
    {
        ret = (uint8)FL_FAILED;
    }

    /* reset download step */
    FldownloadStatus.downloadStep = FL_REQUEST_STEP;

    return ret;
}


void FL_MainFunction(void)
{
    switch (FldownloadStatus.activeJob)
    {
    case FL_JOB_ERASING:
        /* do the flash erase */
        FldownloadStatus.errorCode = FL_Erasing();
        break;

    case FL_JOB_PROGRAMMING:
        /* do the flash program */
        FldownloadStatus.errorCode = FL_Programming();
        break;

    case FL_JOB_CHECKING:
        /* do the flash checksum */
        FldownloadStatus.errorCode = FL_CheckSuming();
        break;

    default:
        break;
    }

    if (FldownloadStatus.errorCode != (uint8)FL_OK)
    {
        /* initialize the flash download state */
        FL_InitState();
    }
    else
    {
        /* empty */
    }

    FldownloadStatus.activeJob = FL_JOB_IDLE;

    return;
}

















