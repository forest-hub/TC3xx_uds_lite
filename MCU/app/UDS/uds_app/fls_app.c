/**
 *
 * \copyright Copyright (c) 2019 Infineon Technologies AG. All rights reserved.
 *
 *
 *
 *                                 IMPORTANT NOTICE
 *
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such
 * terms of use are agreed, use of this file is subject to following:


 * Boost Software License - Version 1.0 - August 17th, 2003

 * Permission is hereby granted, free of charge, to any person or
 * organization obtaining a copy of the software and accompanying
 * documentation covered by this license (the "Software") to use, reproduce,
 * display, distribute, execute, and transmit the Software, and to prepare
 * derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:

 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.

 *
 */

/* Include Header Files ------------------------------------------------------*/

#include "fls_app.h"
#include "fl_cfc.h"
#include "uds_server.h"
#include "dflash.h"

/** flashloader status information */
/*request time status define*/
#define REQ_TIME_SUCCESSFUL                             (1u)
#define REQ_TIME_FAILED                                 (2u)
static  tEraseFlashStep                                 gs_eEraseFlashStep = START_ERASE_FLASH;
/*get current erase falsh step*/
#define Flash_GetCurEraseFlashStep()                     (gs_eEraseFlashStep)
#define Flash_SetEraseFlashStep(eEraseStep)              do{ gs_eEraseFlashStep = (eEraseStep);}while(0u)
/*Is request time successful?*/
static  uint8 gs_reqTimeStatus = 0xFFu;
extern  tFlsDownloadStateType                            gs_stFlashDownloadInfo;
extern  tAppFlashStatus                                  gs_stAppFlashStatus;
/*set request time status*/
#define Flash_ClearRequestTimeStauts()                   do{ gs_reqTimeStatus = 0xFFu; }while(0u)
#define Flash_SetRequestMoreTimeStatus(status)           do{ gs_reqTimeStatus = status; }while(0u)
#define Flash_IsReqestTimeSuccessfull()                  ((1u == gs_reqTimeStatus) ? TRUE : FALSE)
#define Flash_IsRequestTimeFailed()                      (((2u == gs_reqTimeStatus)) ? TRUE : FALSE)

static uint8 Flash_Erase(void);
static uint8 Flash_Write(boolean * o_pbIsOperateFinsh);
static uint8 Flash_Checksum(boolean * o_pbIsOperateFinsh);

/*Request mo retime sccessful from host.
**i_txMsgStatus: 0 is successful, others is failed.
*/
static void RequetMoreTimeSuccessfulFromHost(uint8 i_txMsgStatus)
{
    if(0u == i_txMsgStatus)
    {
        /*request time successful*/
        Flash_SetRequestMoreTimeStatus(REQ_TIME_SUCCESSFUL);
    }
    else
    {
        /*tx message failed.*/
        Flash_SetRequestMoreTimeStatus(REQ_TIME_FAILED);
    }
}


/*restore operate flash active job*/
static void Flash_RestoreOperateFlashActiveJob(const tFlshJobModle i_activeJob)
{
    gs_stFlashDownloadInfo.eActiveJob = i_activeJob;
}

/*Init flash download*/
void Flash_InitDowloadInfo(void)
{
    gs_stFlashDownloadInfo.isFingerPrintWritten = FALSE;
    if(TRUE == gs_stFlashDownloadInfo.isFlashDrvDownloaded)
    {
       //Flash_EraseFlashDriverInRAM();
        gs_stFlashDownloadInfo.isFlashDrvDownloaded = TRUE;
    }

    Flash_SetNextDownloadStep(FL_REQUEST_STEP);
    Flash_SetOperateFlashActiveJob(FLASH_IDLE, NULL_PTR, INVALID_UDS_SERVICES_ID, NULL_PTR);
    gs_stFlashDownloadInfo.pstAppFlashStatus = &gs_stAppFlashStatus;
    memset(&gs_stFlashDownloadInfo.stFlashOperateAPI, 0x0u, sizeof(tFlashOperateAPI));
    memset(&gs_stAppFlashStatus, 0xFFu, sizeof(tAppFlashStatus));
}

/*flash operate main function*/
void Flash_OperateMainFunction(void)
{
    tFlshJobModle currentFlashJob = FLASH_IDLE;
    boolean bIsOperateFinshed = FALSE;

    currentFlashJob = Flash_GetOperateFlashActiveJob();

    switch (currentFlashJob)
    {
        case FLASH_ERASING:

            /* do the flash erase*/
            bIsOperateFinshed = FALSE;
            gs_stFlashDownloadInfo.errorCode = Flash_Erase();

            break;

        case FLASH_PROGRAMMING:

            bIsOperateFinshed = TRUE;
            /* do the flash program*/
            gs_stFlashDownloadInfo.errorCode = Flash_Write(&bIsOperateFinshed);

            break;

        case FLASH_CHECKING:

            /* do the flash checksum*/
            bIsOperateFinshed = TRUE;
            gs_stFlashDownloadInfo.errorCode = Flash_Checksum(&bIsOperateFinshed);

            break;

        case FLASH_WAITTING:

            if(TRUE == Flash_IsReqestTimeSuccessfull())
            {
                Flash_ClearRequestTimeStauts();

             //   Flash_RestoreInterruptedJob();
                Flash_RestoreOperateFlashActiveJob(FLASH_ERASING);
            }
            else if(TRUE == Flash_IsRequestTimeFailed())
            {
                Flash_ClearRequestTimeStauts();

                /*set erase flash step to start!*/
                Flash_SetEraseFlashStep(START_ERASE_FLASH);

                /* initialize the flash download state */
                Flash_InitDowloadInfo();

                /*set flash job is IDLE*/
                Flash_SetOperateFlashActiveJob(FLASH_IDLE, NULL_PTR, INVALID_UDS_SERVICES_ID, NULL_PTR);
            }
            else
            {
                /*do nothing*/

            }

            break;

        default:
            break;
    }

    /*just operate flash finshed, can do callback and set next job.*/
    if(TRUE == bIsOperateFinshed)
    {
        if((NULL_PTR != gs_stFlashDownloadInfo.pfActiveJobFinshedCallBack) && (FLASH_IDLE != currentFlashJob))
        {
            (gs_stFlashDownloadInfo.pfActiveJobFinshedCallBack)(gs_stFlashDownloadInfo.errorCode);

            gs_stFlashDownloadInfo.pfActiveJobFinshedCallBack = NULL_PTR;
        }

        if ((gs_stFlashDownloadInfo.errorCode != TRUE) &&
            ((FLASH_ERASING == currentFlashJob) ||
             (FLASH_PROGRAMMING == currentFlashJob) ||
             (FLASH_CHECKING == currentFlashJob)))
        {
            /* initialize the flash download state */
            Flash_InitDowloadInfo();
        }

        /*set flash job is IDLE*/
        Flash_SetOperateFlashActiveJob(FLASH_IDLE, NULL_PTR, INVALID_UDS_SERVICES_ID, NULL_PTR);
    }
}


/* Fash Erase*/
static uint8 Flash_Erase(void)
{

    uint8  s_result = -1;
    static tAPPType s_appType = APP_INVLID_TYPE;
    static const FL_DescriptorType *o_pAppInfoStartAddr = NULL;
    static FlashOpera_t tFlashOpera;
    static uint32 erasecount=0;
    static uint32 erasec=0;

    //根据存入的info 信息判断哪个区域是最新的镜像，从而擦除老的区域
    //这里只预留双bank程序，实际不实现双bank
    /*check flash driver valid or not?*/
    switch(Flash_GetCurEraseFlashStep())
    {

      case START_ERASE_FLASH:
      /*get old app type*/
       s_appType = Flash_GetOldAPPType();

       if( FLASH_HAL_GetFlashBankInfo(s_appType, &o_pAppInfoStartAddr) ==TRUE )
       {
          if(o_pAppInfoStartAddr!=NULL)
          {
            memset(&tFlashOpera,0,sizeof(tFlashOpera));

            Flash_SetEraseFlashStep(DO_ERASING_FLASH);
          }
       }

       break;

       case DO_ERASING_FLASH:

       for(uint8 i = 0;i < PBLK_NUM_MAX;i++)
       {
          s_result =  HAL_GetFlashOperationInfo(o_pAppInfoStartAddr[i].address, o_pAppInfoStartAddr[i].endaddress, &tFlashOpera);

          if (s_result != 0)
          {
              Flash_SetEraseFlashStep(END_ERASE_FLASH);
              return s_result;
          }

          erasec = tFlashOpera.startSector;

          if (erasec > tFlashOpera.endSector)
          {
              Flash_SetEraseFlashStep(END_ERASE_FLASH);
              return 0xFE;
          }

          while(erasec <= tFlashOpera.endSector)
          {
             s_result= Hal_Flash_Erase(&tFlashOpera,erasec);

             if( s_result!=0 )
             {
                //擦除失败，放弃擦除
                //发送失败
                 erasec=0;
                Flash_SetEraseFlashStep(END_ERASE_FLASH);
                return s_result;
             }

             erasecount++;
             erasec++;

             if(tFlashOpera.eFlashType==FLASH_TYPE_P_FLASH)
             {
               if( (erasecount % 2) == 0 )
               {
                   //喂狗
               }

             }else if(tFlashOpera.eFlashType==FLASH_TYPE_D_FLASH)
             {
               if( (erasecount % 8) == 0 )
               {
                  //喂狗
               }

             }else{

                Flash_SetEraseFlashStep(END_ERASE_FLASH);
                return 0xFF;
              }
          }

       }

       Flash_SetEraseFlashStep(END_ERASE_FLASH);

       return s_result;
       break;

       case END_ERASE_FLASH:

        erasecount=0;
        erasec=0;
        o_pAppInfoStartAddr=NULL;
        memset(&tFlashOpera, 0, sizeof(tFlashOpera));

        Flash_SetEraseFlashStep(START_ERASE_FLASH);

        break;

    default:

        Flash_SetEraseFlashStep(START_ERASE_FLASH);

        break;
}

return s_result;
   
}


/*flash write */
static uint8 Flash_Write(boolean * o_pbIsOperateFinsh)
{
    

    return 0;
}


/*flash check sum */
static uint8 Flash_Checksum(boolean * o_pbIsOperateFinsh)
{


    return 0;
}







