/********************************************************************************************************************
 * \file MCMCAN_FD.c
 * \copyright Copyright (C) Infineon Technologies AG 2020
 *
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are solely in the form of
 * machine-executable object code generated by a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *********************************************************************************************************************/

/*********************************************************************************************************************/
/*-----------------------------------------------------Includes------------------------------------------------------*/
/*********************************************************************************************************************/
#include <can.h>
#include <stm.h>
#include <IfxCan.h>
#include "Comm/Ifx_Console.h"
#include "FreeRTOS.h"
#include "semphr.h"
#include "task.h"
#include "uart.h"
/*********************************************************************************************************************/
/*-------------------------------------------------Global variables--------------------------------------------------*/
/*********************************************************************************************************************/

const NodeCanCfg_t CAN_cfgTable[8] = {
        // CAN0 node00
        {
          {&IfxCan_TXD00_P02_0_OUT,IfxPort_OutputMode_pushPull,&IfxCan_RXD00A_P02_1_IN,IfxPort_InputMode_pullUp,
           IfxPort_PadDriver_cmosAutomotiveSpeed4},
           MODULE_CAN0_RAM, NODE0_RAM_OFFSET,IfxCan_NodeId_0, ISR_PRIORITY_CAN00_TX, ISR_PRIORITY_CAN00_RX,
           ISR_PRIORITY_CAN00_ERR, IfxCan_InterruptLine_0, IfxCan_InterruptLine_1,IfxCan_InterruptLine_2
        },
        // CAN0 node 01
        {
          { &IfxCan_TXD01_P33_9_OUT,IfxPort_OutputMode_pushPull,&IfxCan_RXD01D_P33_10_IN,IfxPort_InputMode_pullUp,
            IfxPort_PadDriver_cmosAutomotiveSpeed4 },
            MODULE_CAN0_RAM,NODE1_RAM_OFFSET,IfxCan_NodeId_1,ISR_PRIORITY_CAN01_TX,ISR_PRIORITY_CAN01_RX,
            ISR_PRIORITY_CAN01_ERR, IfxCan_InterruptLine_3,IfxCan_InterruptLine_4,IfxCan_InterruptLine_5
        },
        // CAN0 node 02
        {
            { &IfxCan_TXD02_P15_0_OUT,IfxPort_OutputMode_pushPull, &IfxCan_RXD02A_P15_1_IN,IfxPort_InputMode_pullUp,
            IfxPort_PadDriver_cmosAutomotiveSpeed4 },
            MODULE_CAN0_RAM,NODE2_RAM_OFFSET,IfxCan_NodeId_2, ISR_PRIORITY_CAN02_TX,ISR_PRIORITY_CAN02_RX,
            ISR_PRIORITY_CAN02_ERR,IfxCan_InterruptLine_6,IfxCan_InterruptLine_7,IfxCan_InterruptLine_8
        },
          // CAN0 node 03
        {
           {&IfxCan_TXD03_P32_3_OUT,IfxPort_OutputMode_pushPull,&IfxCan_RXD03B_P32_2_IN,IfxPort_InputMode_pullUp,    // CAN03_RX
            IfxPort_PadDriver_cmosAutomotiveSpeed4},
            MODULE_CAN0_RAM,NODE3_RAM_OFFSET, IfxCan_NodeId_3,ISR_PRIORITY_CAN03_TX,ISR_PRIORITY_CAN03_RX,
            ISR_PRIORITY_CAN03_ERR,IfxCan_InterruptLine_9, IfxCan_InterruptLine_10,IfxCan_InterruptLine_11
         },
           // CAN1 node 00
         {
           {&IfxCan_TXD10_P00_0_OUT,IfxPort_OutputMode_pushPull,&IfxCan_RXD10A_P00_1_IN,IfxPort_InputMode_pullUp,    // CAN10_RX
            IfxPort_PadDriver_cmosAutomotiveSpeed4},
            MODULE_CAN1_RAM,NODE0_RAM_OFFSET,IfxCan_NodeId_0,ISR_PRIORITY_CAN10_TX,ISR_PRIORITY_CAN10_RX,
            ISR_PRIORITY_CAN10_ERR,IfxCan_InterruptLine_0, IfxCan_InterruptLine_1,IfxCan_InterruptLine_2
          },
          // CAN1 node 01
        {
          {&IfxCan_TXD11_P00_4_OUT,IfxPort_OutputMode_pushPull,&IfxCan_RXD11B_P00_5_IN,IfxPort_InputMode_pullUp,    // CAN11_RX
           IfxPort_PadDriver_cmosAutomotiveSpeed4 },
           MODULE_CAN1_RAM,NODE1_RAM_OFFSET, IfxCan_NodeId_1,ISR_PRIORITY_CAN11_TX,ISR_PRIORITY_CAN11_RX,
           ISR_PRIORITY_CAN11_ERR,IfxCan_InterruptLine_3, IfxCan_InterruptLine_4,IfxCan_InterruptLine_5
         },
         // CAN1 node 02
        {
          {&IfxCan_TXD12_P20_7_OUT,IfxPort_OutputMode_pushPull,&IfxCan_RXD12A_P20_6_IN,IfxPort_InputMode_pullUp,    // CAN12_RX
           IfxPort_PadDriver_cmosAutomotiveSpeed4 },
           MODULE_CAN1_RAM,NODE2_RAM_OFFSET, IfxCan_NodeId_2, ISR_PRIORITY_CAN12_TX,ISR_PRIORITY_CAN12_RX,
           ISR_PRIORITY_CAN12_ERR, IfxCan_InterruptLine_6, IfxCan_InterruptLine_7,IfxCan_InterruptLine_8
         },
         // CAN1 node 03
        {
          { &IfxCan_TXD13_P33_4_OUT,IfxPort_OutputMode_pushPull,&IfxCan_RXD13B_P33_5_IN,IfxPort_InputMode_pullUp,    // CAN13_RX
           IfxPort_PadDriver_cmosAutomotiveSpeed4},
           MODULE_CAN1_RAM,NODE3_RAM_OFFSET,IfxCan_NodeId_3,ISR_PRIORITY_CAN13_TX,ISR_PRIORITY_CAN13_RX,
           ISR_PRIORITY_CAN13_ERR, IfxCan_InterruptLine_9,IfxCan_InterruptLine_10,IfxCan_InterruptLine_11
         },
};
const uint32  sBaudCBT[BPS_NUM]   =                   {0,50,100,125,250,500,1000};
const uint32  sBaudFDCBT[BPS_FD_NUM] =                {0,1000,2000,4000,5000,8000};
const uint16  samplingpointArr[samplePoint_NUM] =     {700,750,800,850,875,900};
const uint16  FDsamplingpointArr[fdsamplePoint_NUM] = {700,750,800,850,875};

const uint8  nodeID_MCU0[8] =         {0,1,2,3,4,5,6,7};
const uint8  nodeID_MCU1[8] =         {7,1,3,5,4,0,6,2};
IfxCan_Can_Node  g_mcmcanNode[8];
uint32 can00cnt;
uint32 can01cnt;
uint32 can02cnt;
uint32 can03cnt;
uint32 can10cnt;
uint32 can11cnt;
uint32 can12cnt;
uint32 can13cnt;

SemaphoreHandle_t can0_xSemaphore = NULL;
SemaphoreHandle_t can1_xSemaphore = NULL;
SemaphoreHandle_t can2_xSemaphore = NULL;
/*********************************************************************************************************************/
/*---------------------------------------------Function Implementations----------------------------------------------*/
/*********************************************************************************************************************/
/* Macro to define Interrupt Service Routine.
 * This macro:
 * - defines linker section as .intvec_tc<vector number>_<interrupt priority>.
 * - defines compiler specific attribute for the interrupt functions.
 * - defines the Interrupt service routine as ISR function.
 *
 * IFX_INTERRUPT(isr, vectabNum, priority)
 *  - isr: Name of the ISR function.
 *  - vectabNum: Vector table number.
 *  - priority: Interrupt priority. Refer Usage of Interrupt Macro for more details.
 */

IFX_INTERRUPT(can00IsrRxHandler, 0, ISR_PRIORITY_CAN00_RX);
IFX_INTERRUPT(can01IsrRxHandler, 0, ISR_PRIORITY_CAN01_RX);
IFX_INTERRUPT(can02IsrRxHandler, 0, ISR_PRIORITY_CAN02_RX);
IFX_INTERRUPT(can03IsrRxHandler, 0, ISR_PRIORITY_CAN03_RX);
IFX_INTERRUPT(can10IsrRxHandler, 0, ISR_PRIORITY_CAN10_RX);
IFX_INTERRUPT(can11IsrRxHandler, 0, ISR_PRIORITY_CAN11_RX);
IFX_INTERRUPT(can12IsrRxHandler, 0, ISR_PRIORITY_CAN12_RX);
IFX_INTERRUPT(can13IsrRxHandler, 0, ISR_PRIORITY_CAN13_RX);

IFX_INTERRUPT(can00IsrTxHandler, 0, ISR_PRIORITY_CAN00_TX);
IFX_INTERRUPT(can01IsrTxHandler, 0, ISR_PRIORITY_CAN01_TX);
IFX_INTERRUPT(can02IsrTxHandler, 0, ISR_PRIORITY_CAN02_TX);
IFX_INTERRUPT(can03IsrTxHandler, 0, ISR_PRIORITY_CAN03_TX);
IFX_INTERRUPT(can10IsrTxHandler, 0, ISR_PRIORITY_CAN10_TX);
IFX_INTERRUPT(can11IsrTxHandler, 0, ISR_PRIORITY_CAN11_TX);
IFX_INTERRUPT(can12IsrTxHandler, 0, ISR_PRIORITY_CAN12_TX);
IFX_INTERRUPT(can13IsrTxHandler, 0, ISR_PRIORITY_CAN13_TX);

//IFX_INTERRUPT(can00IsrERRHandler, 1, ISR_PRIORITY_CAN00_ERR);
//IFX_INTERRUPT(can01IsrERRHandler, 1, ISR_PRIORITY_CAN01_ERR);
//IFX_INTERRUPT(can02IsrERRHandler, 1, ISR_PRIORITY_CAN02_ERR);
//IFX_INTERRUPT(can03IsrERRHandler, 1, ISR_PRIORITY_CAN03_ERR);
//IFX_INTERRUPT(can10IsrERRHandler, 1, ISR_PRIORITY_CAN10_ERR);
//IFX_INTERRUPT(can11IsrERRHandler, 1, ISR_PRIORITY_CAN11_ERR);
//IFX_INTERRUPT(can12IsrERRHandler, 1, ISR_PRIORITY_CAN12_ERR);
//IFX_INTERRUPT(can13IsrERRHandler, 1, ISR_PRIORITY_CAN13_ERR);


/* Interrupt Service Routine (ISR) called once the RX interrupt has been generated.
 * Reads the received CAN message and increments a counter confirming to the source node that the previous message
 * has been received.
 */

void can00IsrRxHandler(void)
{
    BaseType_t xHigherPriorityTaskWoken = pdFALSE;
    IfxCan_Node_clearInterruptFlag((Ifx_CAN_N *)g_mcmcanNode[0].node, IfxCan_Interrupt_rxFifo0NewMessage);
    print("1111\r\n");
    xSemaphoreGiveFromISR( can0_xSemaphore, &xHigherPriorityTaskWoken );
    if( xHigherPriorityTaskWoken != pdFALSE )
    {
        portYIELD_FROM_ISR( xHigherPriorityTaskWoken );
    }

}
uint32 can01cnt;
void can01IsrRxHandler(void)
{
    BaseType_t xHigherPriorityTaskWoken = pdFALSE;
    IfxCan_Node_clearInterruptFlag((Ifx_CAN_N *)g_mcmcanNode[1].node, IfxCan_Interrupt_rxFifo0NewMessage);
    xSemaphoreGiveFromISR(can1_xSemaphore, &xHigherPriorityTaskWoken);
   // can01cnt++;
    if( xHigherPriorityTaskWoken != pdFALSE )
    {
        portYIELD_FROM_ISR( xHigherPriorityTaskWoken );
    }
}

void can02IsrRxHandler(void)
{
    BaseType_t xHigherPriorityTaskWoken = pdFALSE;
    IfxCan_Node_clearInterruptFlag((Ifx_CAN_N *)g_mcmcanNode[2].node, IfxCan_Interrupt_rxFifo0NewMessage);
    print("333\r\n");
    xSemaphoreGiveFromISR( can2_xSemaphore, &xHigherPriorityTaskWoken );

    if( xHigherPriorityTaskWoken != pdFALSE )
    {
        portYIELD_FROM_ISR( xHigherPriorityTaskWoken );
    }
}

void can03IsrRxHandler(void)
{
   // BaseType_t xHigherPriorityTaskWoken = pdFALSE;
    IfxCan_Node_clearInterruptFlag((Ifx_CAN_N *)g_mcmcanNode[3].node, IfxCan_Interrupt_rxFifo0NewMessage);
    print("444\r\n");
}

void can10IsrRxHandler(void)
{
   // BaseType_t xHigherPriorityTaskWoken = pdFALSE;
    IfxCan_Node_clearInterruptFlag((Ifx_CAN_N *)g_mcmcanNode[4].node, IfxCan_Interrupt_rxFifo0NewMessage);
    print("555\r\n");
}

void can11IsrRxHandler(void)
{
   // BaseType_t xHigherPriorityTaskWoken = pdFALSE;
    IfxCan_Node_clearInterruptFlag((Ifx_CAN_N *)g_mcmcanNode[5].node, IfxCan_Interrupt_rxFifo0NewMessage);

}
void can12IsrRxHandler(void)
{
   // BaseType_t xHigherPriorityTaskWoken = pdFALSE;
    IfxCan_Node_clearInterruptFlag((Ifx_CAN_N *)g_mcmcanNode[6].node, IfxCan_Interrupt_rxFifo0NewMessage);
    print("6666\r\n");
}
void can13IsrRxHandler(void)
{
   // BaseType_t xHigherPriorityTaskWoken = pdFALSE;
    IfxCan_Node_clearInterruptFlag((Ifx_CAN_N *)g_mcmcanNode[7].node, IfxCan_Interrupt_rxFifo0NewMessage);
    print("7777\r\n");
}

/* Function to initialize MCMCAN module and nodes related for this application use case */
void initMcmcan(uint8 nodeid, canInitConfigType  *canInitConfig)
{
    bps_goal bps =    canInitConfig->baudrate;
    bpsfd_goal fdbps =canInitConfig->FDbaudrate;
    samplingpoint spoint =  canInitConfig->samplingpoint;
    FDsamplingpoint fdspoint = canInitConfig->FDsamplingpoint;

    IfxCan_Can_Config canConfig;                            /* CAN module configuration structure                   */
    IfxCan_Can canModule;                                   /* CAN module handle                                    */
    IfxCan_Can_NodeConfig canNodeConfig;                    /* CAN node configuration structure                     */

    IfxCan_Can_initModuleConfig(&canConfig,(Ifx_CAN*)CAN_cfgTable[nodeid].ramBaseAddr);
    IfxCan_Can_initModule(&canModule, &canConfig);
    IfxCan_Can_initNodeConfig(&canNodeConfig, &canModule);

     canNodeConfig.nodeId = CAN_cfgTable[nodeid].nodeId;
     canNodeConfig.frame.type = canInitConfig->listenMode;
     //canNodeConfig.frame.mode =  IfxCan_FrameMode_fdLongAndFast ;
     canNodeConfig.txConfig.txMode = IfxCan_TxMode_fifo;
     canNodeConfig.txConfig.txFifoQueueSize = 20;
     canNodeConfig.txConfig.dedicatedTxBuffersNumber = 0;
     canNodeConfig.txConfig.txBufferDataFieldSize = IfxCan_DataFieldSize_64;


     canNodeConfig.rxConfig.rxMode = IfxCan_RxMode_fifo0;
     canNodeConfig.rxConfig.rxFifo0Size = 4;
     canNodeConfig.rxConfig.rxFifo1Size = 0;
     canNodeConfig.rxConfig.rxFifo0DataFieldSize = IfxCan_DataFieldSize_64;
     canNodeConfig.rxConfig.rxFifo1DataFieldSize = IfxCan_DataFieldSize_64;
     canNodeConfig.rxConfig.rxFifo0OperatingMode = IfxCan_RxFifoMode_overwrite;   //or block
     canNodeConfig.rxConfig.rxFifo1OperatingMode = IfxCan_RxFifoMode_overwrite;

     //Message RAM
     canNodeConfig.messageRAM.baseAddress =CAN_cfgTable[nodeid].ramBaseAddr;
     canNodeConfig.messageRAM.rxFifo0StartAddress = 0x100 + CAN_cfgTable[nodeid].ramBaseAddrOffset;
     canNodeConfig.messageRAM.txBuffersStartAddress = 0x6A0 + CAN_cfgTable[nodeid].ramBaseAddrOffset;
     //Total: 128 + 128 + 1440 + 1440 = 3136 Bytes
     if(bps==BPS_NULL)
     {
         //receive interrupt
         canNodeConfig.interruptConfig.rxFifo0NewMessageEnabled = FALSE;
         canNodeConfig.interruptConfig.rxf0n.priority = CAN_cfgTable[nodeid].priorityRX;
         canNodeConfig.interruptConfig.rxf0n.interruptLine = CAN_cfgTable[nodeid].interruptLineRX;
         canNodeConfig.interruptConfig.rxf0n.typeOfService =IfxSrc_Tos_cpu0;
         canNodeConfig.interruptConfig.protocolErrorDataEnabled = FALSE;
         canNodeConfig.interruptConfig. protocolErrorArbitrationEnabled = FALSE;
         canNodeConfig.interruptConfig.loi.priority = CAN_cfgTable[nodeid].priorityERR;
         canNodeConfig.interruptConfig.loi.interruptLine = CAN_cfgTable[nodeid].interruptLineERR;
         canNodeConfig.interruptConfig.loi.typeOfService =IfxSrc_Tos_cpu0;

         //transmit interrupt
         canNodeConfig.interruptConfig.transmissionCompletedEnabled = FALSE;
         canNodeConfig.interruptConfig.traco.priority = CAN_cfgTable[nodeid].priorityTX;
         canNodeConfig.interruptConfig.traco.interruptLine = CAN_cfgTable[nodeid].interruptLineTX;
         canNodeConfig.interruptConfig.traco.typeOfService = IfxSrc_Tos_cpu0;

         //ERR interrupt
        // canNodeConfig.interruptConfig.busOffStatusEnabled = FALSE;
        // canNodeConfig.interruptConfig.rxf0n.priority = CAN_cfgTable[nodeid].priorityERR;
        // canNodeConfig.interruptConfig.rxf0n.interruptLine = CAN_cfgTable[nodeid].interruptLineERR;
        // canNodeConfig.interruptConfig.rxf0n.typeOfService =IfxSrc_Tos_cpu1;
     }else{
         //receive interrupt
         canNodeConfig.interruptConfig.rxFifo0NewMessageEnabled = TRUE;
         canNodeConfig.interruptConfig.rxf0n.priority = CAN_cfgTable[nodeid].priorityRX;
         canNodeConfig.interruptConfig.rxf0n.interruptLine = CAN_cfgTable[nodeid].interruptLineRX;
         canNodeConfig.interruptConfig.rxf0n.typeOfService =IfxSrc_Tos_cpu0;

         //canNodeConfig.interruptConfig.protocolErrorDataEnabled = TRUE;
         //canNodeConfig.interruptConfig. protocolErrorArbitrationEnabled = TRUE;
         //canNodeConfig.interruptConfig.loi.priority = CAN_cfgTable[nodeid].priorityERR;
         //canNodeConfig.interruptConfig.loi.interruptLine = CAN_cfgTable[nodeid].interruptLineERR;
         //canNodeConfig.interruptConfig.loi.typeOfService =IfxSrc_Tos_cpu1;

        //手册40-112 MRAF 及 40-7 图 40-80表 可以看到 MARF属于moer中断组
        //手册40-114 MARF中断
        //手册40-106 ECRi错误计数
        //手册40-107 PSRi错误种类
        //transmit interrupt
       // canNodeConfig.interruptConfig.transmissionCompletedEnabled = TRUE;
       // canNodeConfig.interruptConfig.traco.priority = CAN_cfgTable[nodeid].priorityTX;
       // canNodeConfig.interruptConfig.traco.interruptLine = CAN_cfgTable[nodeid].interruptLineTX;
       // canNodeConfig.interruptConfig.traco.typeOfService = IfxSrc_Tos_cpu0;
     }

        //clock: 80M
        canNodeConfig.baudRate.baudrate =sBaudCBT[bps]*1000;
        canNodeConfig.baudRate.samplePoint =samplingpointArr[spoint]*10;
        //canNodeConfig.baudRate.samplePoint =7000;
        canNodeConfig.calculateBitTimingValues = TRUE;
       if(bps!=BPS_NULL && fdbps!=BPS_notuse )
       {
           canNodeConfig.fastBaudRate.baudrate = sBaudFDCBT[fdbps]*1000;
           canNodeConfig.fastBaudRate.samplePoint =FDsamplingpointArr[fdspoint]*10;
           //canNodeConfig.fastBaudRate.samplePoint =7000;
           canNodeConfig.fastBaudRate.tranceiverDelayOffset = 28;
           canNodeConfig.frame.mode =  IfxCan_FrameMode_fdLongAndFast ;
       }
       else
       {
           canNodeConfig.fastBaudRate.baudrate = 0;
           canNodeConfig.fastBaudRate.samplePoint =0;
           canNodeConfig.frame.mode =IfxCan_FrameMode_standard ;
       }
       can0_xSemaphore= xSemaphoreCreateCounting(10,0);
       can1_xSemaphore= xSemaphoreCreateCounting(10,0);
       can2_xSemaphore= xSemaphoreCreateCounting(10,0);
       canNodeConfig.pins= &CAN_cfgTable[nodeid].pin;
       IfxCan_Can_initNode(&g_mcmcanNode[nodeid], &canNodeConfig);
}


/* Function to initialize both TX and RX messages with the default data values.
 * After initialization of the messages, the TX message is transmitted.
 */

uint8 transmitCanMessage(uint8 nodeid,uint32 messageID,uint32 *data,IfxCan_DataLengthCode len,IfxCan_MessageIdLength extended,IfxCan_FrameMode mode)
{
    uint32 temp;
    IfxCan_Message txMsg;
    temp=IfxCan_Node_getLastErroCodeStatus(g_mcmcanNode[nodeid].node);

    if(temp!=0)
    {
      IfxCan_Node_disableConfigurationChange(g_mcmcanNode[nodeid].node);// 恢复通信
    }
      IfxCan_Can_initMessage(&txMsg);
      // change the relevent members of message structure
      txMsg.dataLengthCode    = len;
      txMsg.frameMode         = mode;
      txMsg.messageIdLength   = extended;//发送不能使用both,必须指明是stand还是extend
      txMsg.messageId         = messageID;
      txMsg.storeInTxFifoQueue = TRUE;// 写入 TX FIFO
     // Ifx_Console_print("can send\r\n");
    if((IfxCan_Can_sendMessage(&g_mcmcanNode[nodeid], &txMsg, data))==IfxCan_Status_ok)
    {
        //UDS 发送成功处理
        //根据诊断类ID处理
        TP_DoTxMsgSuccesfulCallback();
    };

    return 0;
}







